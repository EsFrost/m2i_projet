This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-20T10:00:49.377Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
controllers/CategoriesController.js
controllers/CommentsController.js
controllers/DownloadsController.js
controllers/LikesController.js
controllers/PhotoController.js
controllers/UserController.js
index.js
models/CategoriesModel.js
models/CommentsModel.js
models/DownloadsModel.js
models/LikesModel.js
models/PhotoModel.js
models/UserModel.js
package.json
routes/categoriesRoute.js
routes/commentsRoute.js
routes/downloadsRoute.js
routes/likesRoute.js
routes/photoRoute.js
routes/userRoute.js
todo
utils/db.js
utils/jwt.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Node modules
node_modules/

# Environment variables
.env

================
File: controllers/CategoriesController.js
================
const { v4: uuidv4 } = require('uuid')
const { createCategory } = require('../models/CategoriesModel')
const sanitizeHtml = require('sanitize-html')
const validator = require('validator')

const categoryModel = require('../models/CategoriesModel')

async function showCategories(req, res) {
    try {
        const result = await categoryModel.getCategories()
        res.send(result.rows)
    }
    catch (err) {
        res.send(err)
    }
}

/* Untested functionality */
async function showCategoryById(req, res) {
    const id = req.params.id
    if (validator.isUUID(id)) {
        try {
            const result = await categoryModel.getCategoryById(id)
            res.status(201).json({result: result.rows})
        }
        catch (err) {
            res.status(500).json({message: "Failed to get category", error: err})
        }
    }
    else {
        res.status(400).json({message: "Invalid UUID"})
    }
}

/* Untested functionality */
async function showCategoryByName(req, res) {
    const name = req.params.name
    if (validator.isString(name)) {
        try {
            const result = await categoryModel.getCategoryByName(name)
            res.status(201).json({result: result.rows})
        }
        catch (err) {
            res.status(500).json({message: "Failed to get category", error: err})
        }
    }
}

/* Untested functionality */
async function createCategory(req, res) {
    let { name, description } = req.body
    const id = uuidv4()
    let sanitizedName = sanitizeHtml(name)
    let sanitizedDescription = sanitizeHtml(description)

    if (validator.isUUID(id) && (name && description)) {
        try {
            await categoryModel.createCategory(id, sanitizedName, sanitizedDescription)
            res.status(201).json({message: "Category created successfully"})
        }
        catch (err) {
            res.status(500).json({message: "Failed to create category", error: err})
        }
    }
}

module.exports = {
    showCategories,
    createCategory,
    showCategoryById,
    showCategoryByName
}

================
File: controllers/CommentsController.js
================
const commentsModel = require('../models/CommentsModel')
const sanitizeHtml = require('sanitize-html')
const validator = require('validator')
const { v4: uuidv4 } = require('uuid')

async function showActivePhotoComments(req, res) {
    let { p_id } = req.params
    p_id = sanitizeHtml(p_id)

    if (validator.isUUID(p_id)) {
        commentsModel.getPhotoComments(p_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.status(400).json({ "error": "Invalid photo id!" })
    }
}

async function showAllPhotoComments(req, res) {
    let { p_id } = req.params
    p_id = sanitizeHtml(p_id)

    if (validator.isUUID(p_id)) {
        commentsModel.getAllPhotoComments(p_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.status(400).json({ "error": "Invalid photo id!" })
    }
}

module.exports = {
    showActivePhotoComments,
    showAllPhotoComments
}

================
File: controllers/DownloadsController.js
================
const downloadsModel = require('../models/DownloadsModel')
const sanitizeHtml = require('sanitize-html')
const validator = require('validator')
const { v4: uuidv4 } = require('uuid')

/* Helper function */
async function checkDownloads(id_user, id_photo) {
    try {
        const result = await downloadsModel.getAllDownloads()
        return result.rows.some(item => item.id_photo === id_photo && item.id_user === id_user)
    } catch (err) {
        console.log(err)
        throw err
    }
}

async function addDownload(req, res) {
    let { id_user, id_photo } = req.body
    id_user = sanitizeHtml(id_user)
    id_photo = sanitizeHtml(id_photo)
    const id = uuidv4()

    if (validator.isUUID(id) && validator.isUUID(id_user) && validator.isUUID(id_photo)) {
        try {
            const check = await checkDownloads(id_user, id_photo)
            if (check === true) {
                res.status(201).json({ "warning": "You have already downloaded this photo!" })
            }
            else {
                downloadsModel.addDownload(id, id_user, id_photo)
                    .then(() => {
                        res.status(201).json({ "message": "Download added to library successfully!" })
                    })
                    .catch(err => {
                        res.status(500).json({ "error": "Internal server error!", err })
                    })
                }
            }
        catch (err) {
            res.status(500).json({ "error": "Internal server error!", err })
        }
    }
    else {
        res.status(400).json({ "error": "Invalid data!" })
    }
}

async function showUserDownloads(req, res) {
    let u_id = req.params.u_id
    u_id = sanitizeHtml(u_id)
    if (validator.isUUID(u_id)) {
        downloadsModel.getUserDownloads(u_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.send(400).json({ "message" : "Invalid user id!" })
    }
}

module.exports = {
    showUserDownloads,
    addDownload
}

================
File: controllers/LikesController.js
================
const likesModel = require('../models/LikesModel')
const sanitizeHtlm = require('sanitize-html')
const validator = require('validator')
const { v4: uuidv4 } = require('uuid')

async function showLikes(req, res) {
    let p_id = req.params.p_id
    p_id = sanitizeHtlm(p_id)
    if (validator.isUUID(p_id)) {
        likesModel.countPhotoLikes(p_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.status(400).json({ "error": "Invalid photo id!" })
    }
}

async function getUserLikes(req, res) {
    let u_id = req.params.u_id
    u_id = sanitizeHtlm(u_id)
    if (validator.isUUID(u_id)) {
        likesModel.getUserLikes(u_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.status(400).json({ "error": "Invalid user id!" })
    }
}

async function getPhotoLikes(req, res) {
    let p_id = req.params.p_id
    p_id = sanitizeHtlm(p_id)
    if (validator.isUUID(p_id)) {
        likesModel.getPhotoLikes(p_id)
            .then(result => {
                res.status(201).json(result.rows)
            })
            .catch(err => {
                res.status(500).json(err)
            })
    }
    else {
        res.status(400).json({ "error": "Invalid photo id!" })
    }
}

/* Helper function */
async function checkLikes(id_user, id_photo) {
    try {
        const result = await likesModel.getAllLikes()
        return result.rows.some(item => item.id_photo === id_photo && item.id_user === id_user)
    } catch (err) {
        throw err
    }
}

/* If the user has already liked the photo, the request has to fail */
async function addLike(req, res) {
    let { id_user, id_photo } = req.body
    id_user = sanitizeHtlm(id_user)
    id_photo = sanitizeHtlm(id_photo)
    const id = uuidv4()

    if (validator.isUUID(id) && validator.isUUID(id_user) && validator.isUUID(id_photo)) {
        try {
            const check = await checkLikes(id_user, id_photo)
            if (check === true) {
                res.status(201).json({ "warning": "You have already liked this photo!" })
            }
            else {
                likesModel.likePhoto(id, id_user, id_photo)
                    .then(() => {
                        res.status(201).json({ "message": "Like added successfully!" })
                    })
                    .catch(err => {
                        res.status(500).json({ "error": "Internal server error!", err })
                    })
                }
            }
        catch (err) {
            res.status(500).json({ "error": "Internal server error!", err })
        }
    }
    else {
        res.status(400).json({ "error": "Invalid data!" })
    }
}

async function deleteLike(req, res) {
    let { id_user, id_photo } = req.params
    id_user = sanitizeHtlm(id_user)
    id_photo = sanitizeHtlm(id_photo)
    if (validator.isUUID(id_user) && validator.isUUID(id_photo)) {
        try {
            const check = await checkLikes(id_user, id_photo)
            if (check === true) {
                likesModel.unlikePhoto(id_user, id_photo)
                    .then(() => {
                        res.status(201).json({ "message": "Photo unliked!" })
                    })
                    .catch(err => {
                        res.status(500).json({ "error": "Internal server error!", err })
                    })
                }
            else {
                res.status(201).json({ "warning": "You have not liked this photo!" })
            }
        }
        catch (err) {
            res.status(500).json({ "error": "Internal server error!", err })
        }
    }
    else {
        res.status(400).json({ "error": "Invalid data!" })
    }
}

module.exports = { 
    showLikes,
    getUserLikes,
    getPhotoLikes,
    addLike,
    deleteLike
}

================
File: controllers/PhotoController.js
================
const photoModel = require('../models/PhotoModel')
const jwt = require('jsonwebtoken')
require('dotenv').config()
const sanitizeHtml = require('sanitize-html')
const validator = require('validator')
const { v4: uuidv4 } = require('uuid')

async function showActivePhotos(req, res) {
    try {
        const result = await photoModel.getActivePhotos()
        res.send(result.rows)
    }
    catch (err) {
        res.send(err)
    }  
}

async function showPhotos(req, res) {
    try {
        const result = await photoModel.getPhotos()
        res.send(result.rows)
    }
    catch (err) {
        res.send(err)
    }
}

async function showPhoto(req, res) {
    let id = req.params.id
    id = sanitizeHtml(id)

    if (validator.isUUID(id)) {
        try {
            const result = await photoModel.getPhoto(id)
            res.send(result.rows)
        }
        catch (err) {
            res.send(err)    
        }
    }
    else {
        res.send('Invalid id!')
    }
}

async function showUserPhotos(req, res) {
    let id = req.params.id
    id = sanitizeHtml(id)

    if (validator.isUUID(id)) {
        try {
            const result = await photoModel.getUserPhotos(id)
            res.send(result.rows)
        }
        catch (err) {
            res.send(err)
        }
    }
    else {
        res.send('Invalid id!')
    }
}

async function showUserPhotoById(req, res) {
    let p_id = req.params.p_id
    p_id = sanitizeHtml(p_id)
    let u_id = req.params.u_id
    u_id = sanitizeHtml(u_id)

    if (validator.isUUID(p_id) && validator.isUUID(u_id)) {
        try {
            const result = await photoModel.getUserPhotoById(p_id, u_id)
            res.send(result.rows)
        }
        catch (err) {
            res.send(err)
        }
    }
    else {
        res.send('Invalid id!')
    }
}

function newPhoto(req, res) {
    let { name, description, path, status } = req.body
    let user_id = req.params.id
    let id = uuidv4()

    if (status === undefined || status === '' || status === null || path === undefined || path === null || path === '') {
        status = false
    }

    id = sanitizeHtml(id)
    user_id = sanitizeHtml(user_id)
    name = sanitizeHtml(name)
    description = sanitizeHtml(description)
    path = sanitizeHtml(path)
    
    if (validator.isUUID(user_id) && validator.isUUID(id) && (validator.isURL(path) || path === '' || path === null || path === undefined) && (status === true || status === false)) {
        photoModel.createPhoto(id, user_id, name, description, path, status)
        .then(() => {
            res.status(201).json({ "message": `Photo ${name} created successfully!` })
        })
        .catch(err => {
            res.status(500).json({ "error" : "Internal server error!", err})
        })
    }
    else {
        res.status(400).json({ "error" :'Invalid data!' })
    }
}

function deletePhoto(req, res) {
    let id = req.params.id
    id = sanitizeHtml(id)
    if (validator.isUUID(id)) {
        photoModel.deletePhoto(id)
            .then(() => {
                res.status(201).json({ "message": `Photo deleted successfully!` })
            })
            .catch(err => {
                res.status(500).json({ "error" : "Internal server error!", err})
            })
    }
    else {
        res.status(400).json({ "error" :'Invalid data!' })
    }
}

function editPhoto(req, res) {
    let id = req.params.id
    let { name, description, status } = req.body

    id = sanitizeHtml(id)
    name = sanitizeHtml(name)
    description = sanitizeHtml(description)

    if (validator.isUUID(id) && (status === true || status === false) && name !== undefined && name !== '' && name !== null) {
        photoModel.editPhoto(name, description, status, id)
            .then(() => {
                res.status(201).json({ "message": `Photo updated successfully!` })
            })
            .catch(err => {
                res.status(500).json({ "error" : "Internal server error!", err})
            })
    }
    else {
        res.status(400).json({ "error" :'Invalid data!' })
    }
}

module.exports = {
    showActivePhotos,
    showPhotos,
    showPhoto,
    showUserPhotos,
    showUserPhotoById,
    newPhoto,
    deletePhoto,
    editPhoto
}

================
File: controllers/UserController.js
================
const userModel = require("../models/UserModel");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const secret = process.env.JWT_SECRET;
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function loginUser(req, res) {
  let { email, password } = req.body;
  email = sanitizeHtml(email);
  password = sanitizeHtml(password);

  if (validator.isEmail(email) && validator.isAlphanumeric(password)) {
    try {
      const user = await userModel.getUserByEmail(email);
      if (user.rows.length === 0) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const isMatch = await bcrypt.compare(password, user.rows[0].password);
      if (!isMatch) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = jwt.sign(
        {
          id: user.rows[0].id,
          username: user.rows[0].username,
          email: user.rows[0].email,
        },
        secret,
        { expiresIn: "30d" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      });

      res.status(200).json({
        message: "Login successful",
        token: token,
      });
    } catch (err) {
      res.status(500).json({ error: "Internal server error" });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUsers(req, res) {
  try {
    const result = await userModel.getUsers();
    res.send(result.rows);
  } catch (err) {
    res.send(err);
  }
}

async function showUser(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUser(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUsername(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUsername(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUserByEmail(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    try {
      const result = await userModel.getUserByEmail(email);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  }
}

function registerUser(req, res) {
  let { username, password, email, user_icon } = req.body;
  const id = uuidv4();
  username = sanitizeHtml(username);
  password = sanitizeHtml(password);
  email = sanitizeHtml(email);
  user_icon = sanitizeHtml(user_icon);

  const salt = bcrypt.genSaltSync(10);
  const hash = bcrypt.hashSync(password, salt);

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    validator.isEmail(email) &&
    validator.isAlphanumeric(password) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    userModel
      .newUser(id, username, email, hash, user_icon)
      .then((result) => {
        const user = { id, email, username };
        const token = generateToken(user);
        res.status(201).json({
          message: `User ${email} created successfully!`,
          token,
          user,
        });
      })
      .catch((err) => {
        if (err.code === "23505") {
          res
            .status(400)
            .json({ message: `Email or username already exists!` });
        } else if (err.code === "22P02") {
          res.status(400).json({ message: `Invalid data!` });
        } else {
          res.status(500).json({ error: "Internal server error! " });
        }
      });
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

function delUser(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    try {
      userModel.deleteUser(email);
      res.send({ message: `User ${email} deleted successfully!` });
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid data!");
  }
}

// need to validate using jwt and compare hashed password / id / email / username
function changePass(req, res) {
  let { email, password } = req.body;

  email = sanitizeHtml(email);
  password = sanitizeHtml(password);

  const salt = bcrypt.genSaltSync(10);
  const hash = bcrypt.hashSync(password, salt);

  if (validator.isEmail(email) && validator.isAlphanumeric(password)) {
    userModel
      .editPassword(hash, email)
      .then(() => {
        res.status(201).json({ message: `Password updated successfully!` });
      })
      .catch((err) => {
        res.status(500).json({ error: "Internal server error! " });
      });
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

// validation needed here also
function changeUser(req, res) {
  let { username, user_icon } = req.body;
  let id = req.params.id;

  username = sanitizeHtml(username);
  user_icon = sanitizeHtml(user_icon);

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    userModel
      .editUser(username, user_icon, id)
      .then(() => {
        res.status(201).json({ message: `User updated successfully!` });
      })
      .catch((err) => {
        res.status(500).json({ error: "Internal server error! " });
      });
  }
}

module.exports = {
  showUsers,
  showUser,
  showUsername,
  registerUser,
  showUserByEmail,
  delUser,
  changePass,
  changeUser,
  loginUser,
};

================
File: index.js
================
const express = require("express");
const app = express();
const cors = require("cors");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const cookieParser = require("cookie-parser"); // Add this line
const userRoute = require("./routes/userRoute");
const photoRoute = require("./routes/photoRoute");
const categoriesRoute = require("./routes/categoriesRoute");
const likesRoute = require("./routes/likesRoute");
const downloadsRoute = require("./routes/downloadsRoute");
const commentsRoute = require("./routes/commentsRoute");

app.use(express.json());
app.use(helmet());
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true, // Allows cookies with CORS
  })
);
app.use(cookieParser()); // Uses the cookie parser

const limiter = rateLimit({
  windowsMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per `window` (here, per 15 minutes)
});

app.use(limiter);

app.use("/user", userRoute);
app.use("/photos", photoRoute);
app.use("/categories", categoriesRoute);
app.use("/likes", likesRoute);
app.use("/downloads", downloadsRoute);
app.use("/comments", commentsRoute);

app.listen(3000, () => {
  console.log("Server is running on port 3000");
});

================
File: models/CategoriesModel.js
================
const { pool } = require('../utils/db')

function getCategories() {
    return pool.query(`SELECT * FROM categories`)
}


/* Untested functionality */
function getCategoryById(id) {
    return pool.query(`SELECT * FROM categories WHERE id = $1`, [id])
}

/* Untested functionality */
function getCategoryByName(name) {
    return pool.query(`SELECT * FROM categories WHERE name = $1`, [name])
}


/* Untested functionality */
function createCategory(id, name, description) {
    return pool.query(`INSERT INTO categories (id, name, description) VALUES ($1, $2, $3)`, [id, name, description])
}

module.exports = {
    getCategories,
    createCategory,
    getCategoryById,
    getCategoryByName
}

================
File: models/CommentsModel.js
================
const { pool } = require('../utils/db')

function getPhotoComments(p_id) {
    return pool.query(
        `SELECT * FROM comments WHERE id_photo = $1 AND status = true`,
        [p_id]
    )
}

function getAllPhotoComments(p_id) {
    return pool.query(
        `SELECT * FROM comments WHERE id_photo = $1`,
        [p_id]
    )
}

module.exports = {
    getPhotoComments,
    getAllPhotoComments
}

================
File: models/DownloadsModel.js
================
const { pool } = require('../utils/db')

function getUserDownloads(u_id) {
    return pool.query(`
        SELECT * FROM downloads
        JOIN photos ON downloads.id_photo = photos.id
        WHERE id_user = $1`, [u_id])
}

function addDownload(id, u_id, p_id) {
    return pool.query(`INSERT INTO downloads (id, id_user, id_photo) VALUES ($1, $2, $3)`, [id, u_id, p_id])
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllDownloads() {
    return pool.query(`SELECT id_user, id_photo FROM downloads`)
}


module.exports = {
    getUserDownloads,
    addDownload,
    getAllDownloads
}

================
File: models/LikesModel.js
================
const { pool } = require('../utils/db')

/* Returns all the photos the user has liked */
/* Change star to specific fields due to memory leaks! */
function getUserLikes(u_id) {
    return pool.query(`
        SELECT * FROM likes l
        JOIN photos p ON l.id_photo = p.id
        WHERE l.id_user = $1`, [u_id])
}

/* Should return the username of people that liked the photo */
/* Change star to specific fields due to memory leaks! */
function getPhotoLikes(p_id) {
    return pool.query(`
        SELECT * FROM likes l
        JOIN users u ON l.id_user = u.id
        WHERE l.id_photo = $1`, [p_id])
}

/* Returns the number of likes on a specific photo */
function countPhotoLikes(p_id) {
    return pool.query(`SELECT COUNT(*) FROM likes l
    JOIN photos p ON l.id_photo = p.id
    WHERE l.id_photo = $1`, [p_id])
}

/* Unlike photo */
function unlikePhoto(u_id, p_id) {
    return pool.query(`DELETE FROM likes WHERE id_user = $1 AND id_photo = $2`, [u_id, p_id])
}

/* Like photo */
function likePhoto(id, u_id, p_id) {
    return pool.query(`INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3)`, [id, u_id, p_id])
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllLikes() {
    return pool.query(`SELECT id_user, id_photo FROM likes`)
}

module.exports = {
    getUserLikes,
    getPhotoLikes,
    countPhotoLikes,
    likePhoto,
    getAllLikes,
    unlikePhoto
}

================
File: models/PhotoModel.js
================
const { pool } = require('../utils/db')

function getActivePhotos() {
    return pool.query('SELECT * FROM photos WHERE status = true')
}

function getPhotos() {
    return pool.query('SELECT * FROM photos')
}

function getPhoto(id) {
    const req = `SELECT * FROM photos WHERE id = $1`
    return pool.query(req, [id])
}

function getUserPhotos(id) {
    const req = `SELECT * FROM photos WHERE user_id = $1`
    return pool.query(req, [id])
}

function getUserPhotoById(p_id, u_id) {
    const req = `SELECT * FROM photos WHERE id = $1 AND user_id = $2`
    return pool.query(req, [p_id, u_id])
}

function createPhoto(id, user_id, name, description, path, status) {
    const req = `INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)`
    return pool.query(req, [id, user_id, name, description, path, status])
}


function deletePhoto(id) {
    const req = `DELETE FROM photos WHERE id = $1`
    return pool.query(req, [id])
}

function editPhoto(name, description, status, id) {
    const req = `UPDATE photos SET name = $1, description = $2, status = $3 WHERE id = $4`
    return pool.query(req, [name, description, status, id])
}


module.exports = {
    getActivePhotos,
    getPhotos,
    getPhoto,
    getUserPhotos,
    getUserPhotoById,
    createPhoto,
    deletePhoto,
    editPhoto
}

================
File: models/UserModel.js
================
const { pool } = require('../utils/db')

function getUsers() {
    return pool.query(`SELECT * FROM users`)
}

function getUser(id) {
    const req = `SELECT * FROM users WHERE id = $1`
    return pool.query(req, [id])
}

function getUserByEmail(email) {
    const req = `SELECT * FROM users WHERE email = $1`
    return pool.query(req, [email])
}

function getUsername(id) {
    const req = `SELECT username FROM users WHERE id = $1`
    return pool.query(req, [id])
}


function newUser(id, username, email, password, user_icon) {
    const req = `INSERT INTO users (id, username, email, password, user_icon) VALUES ($1, $2, $3, $4, $5)`
    return pool.query(req, [id, username, email, password, user_icon])
}

function deleteUser(email) {
    const req = `DELETE FROM users WHERE email = $1`
    return pool.query(req, [email])
}

function editUser(username, user_icon, id) {
    const req = `UPDATE users SET username = $1, user_icon = $2 WHERE id = $3`
    return pool.query(req, [username, user_icon, id])
}

async function editPassword(password, email) {

    const req = `UPDATE users SET password = $1 WHERE email = $2`
    return pool.query(req, [password, email])
}

module.exports = { 
    getUsers,
    getUser,
    getUsername,
    newUser,
    getUserByEmail,
    deleteUser,
    editUser,
    editPassword
}

================
File: package.json
================
{
  "name": "photostockage-backend",
  "version": "0.0.1",
  "description": "Backend for a project for my training at m2i",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "backend",
    "node",
    "nodejs"
  ],
  "author": "Sigmund Frost",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "sanitize-html": "^2.13.0",
    "sequelize": "^6.37.3",
    "uuidv4": "^6.2.13",
    "validator": "^13.12.0"
  }
}

================
File: routes/categoriesRoute.js
================
const express = require('express')
const categoriesRouter = express.Router()
const categoriesController = require('../controllers/CategoriesController')

/* method GET */
categoriesRouter.get('/', categoriesController.showCategories)
categoriesRouter.get('/:id', categoriesController.showCategoryById)
categoriesRouter.get('/:name', categoriesController.showCategoryByName)

/* method POST */
/* Untested functionality */
categoriesRouter.post('/', categoriesController.createCategory)

/* method PUT */

/* method DELETE */

module.exports = categoriesRouter

================
File: routes/commentsRoute.js
================
const express = require('express')
const commentsRouter = express.Router()
const commentsController = require('../controllers/CommentsController')

/* method: GET */
commentsRouter.get('/photo/:p_id', commentsController.showActivePhotoComments)
commentsRouter.get('/c_photo/:p_id', commentsController.showAllPhotoComments)

/* method: POST */

/* method: DELETE */

/* method: PUT */

module.exports = commentsRouter

================
File: routes/downloadsRoute.js
================
const express = require('express')
const downloadsRouter = express.Router()
const downloadsController = require('../controllers/DownloadsController')

/* method: GET */
downloadsRouter.get('/user/:u_id', downloadsController.showUserDownloads)

/* method: POST */
downloadsRouter.post('/download', downloadsController.addDownload)

module.exports = downloadsRouter

================
File: routes/likesRoute.js
================
const epxress = require('express')
const likesRouter = epxress.Router()
const likesController = require('../controllers/LikesController')

/* method: GET */
likesRouter.get('/likes/:p_id', likesController.showLikes)
likesRouter.get('/user/:u_id', likesController.getUserLikes)
likesRouter.get('/photo/:p_id', likesController.getPhotoLikes)

/* method: POST */
likesRouter.post('/like', likesController.addLike)

/* method: DELETE */
likesRouter.delete('/like/:id_user/:id_photo', likesController.deleteLike)

module.exports = likesRouter

================
File: routes/photoRoute.js
================
const express = require('express')
const photoRouter = express.Router()
const photoController = require('../controllers/PhotoController')

/* method: GET */
photoRouter.get('/photos/admin', photoController.showPhotos)
photoRouter.get('/photos', photoController.showActivePhotos)
photoRouter.get('/photo/:id', photoController.showPhoto)
photoRouter.get('/photos/user/:id', photoController.showUserPhotos)
photoRouter.get('/photo/user/:p_id/:u_id', photoController.showUserPhotoById)

/* method: POST */
photoRouter.post('/add_photo/:id', photoController.newPhoto)

/* method: DELETE */
photoRouter.delete('/delete/:id', photoController.deletePhoto)

/* method: PUT */
photoRouter.put('/edit/:id', photoController.editPhoto)

module.exports = photoRouter

================
File: routes/userRoute.js
================
const express = require("express");
const userRouter = express.Router();
const userController = require("../controllers/UserController");

/* method: GET */
userRouter.get("/users", userController.showUsers);
userRouter.get("/user/:id", userController.showUser);
userRouter.get("/username/:id", userController.showUsername);
userRouter.get("/email/:email", userController.showUserByEmail);

/* method: POST */
userRouter.post("/register", userController.registerUser);
userRouter.post("/login", userController.loginUser);

/* method: DELETE */
userRouter.delete("/delete/:email", userController.delUser);

/* method: PUT */
userRouter.put("/changepass", userController.changePass);
userRouter.put("/changeuser/:id", userController.changeUser);

module.exports = userRouter;

================
File: todo
================
add message if return.rows is emtpy
add message for errors
implement tokens
implement bcrypt for users controller
add requests to postman

================
File: utils/db.js
================
const { Pool } = require('pg')
require('dotenv').config()

const pool = new Pool({
    connectionString: process.env.DATABASE_URL
})

/* Connection test */

// async function testConnection() {
//     try {
//         // Connect to the database
//         const test = await pool.query('SELECT * FROM users');
//         console.log(test.rows);
//     } catch (err) {
//         console.error('Error connecting to the database:', err.message);
//     }
// }

// testConnection();

module.exports = {
    pool
}

================
File: utils/jwt.js
================
const jwt = require("jsonwebtoken");
require("dotenv").config();

const JWT_SECRET = process.env.JWT_SECRET;

function generateToken(user) {
  return jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, {
    expiresIn: "1d",
  });
}

function verifyToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

module.exports = { generateToken, verifyToken };

// middleware/auth.js

const { verifyToken } = require("../utils/jwt");

function authMiddleware(req, res, next) {
  const token = req.header("Authorization")?.replace("Bearer ", "");

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
}

module.exports = authMiddleware;
