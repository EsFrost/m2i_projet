This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-14T16:15:32.298Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
__tests_/integration/category.test.js
__tests_/integration/comments.test.js
__tests_/integration/downloads.test.js
__tests_/integration/likes.test.js
__tests_/integration/photo.test.js
__tests_/integration/user.test.js
__tests_/setup/testDb.js
.gitignore
controllers/CategoriesController.js
controllers/CommentsController.js
controllers/DownloadsController.js
controllers/LikesController.js
controllers/PhotoController.js
controllers/UserController.js
index.js
middleware/authMiddleware.js
models/CategoriesModel.js
models/CommentsModel.js
models/DownloadsModel.js
models/LikesModel.js
models/PhotoModel.js
models/UserModel.js
package.json
routes/categoriesRoute.js
routes/commentsRoute.js
routes/downloadsRoute.js
routes/likesRoute.js
routes/photoRoute.js
routes/userRoute.js
Tests.md
todo
todo.md
utils/db.js

================================================================
Repository Files
================================================================

================
File: __tests_/integration/category.test.js
================
// __tests__/integration/category.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let adminToken;
let userToken;

beforeAll(async () => {
  // Create admin user
  const adminData = {
    username: "admin",
    email: "admin@test.com",
    password: "Admin123",
    access_level: true,
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password, access_level) VALUES ($1, $2, $3, $4, $5)",
    [
      uuidv4(),
      adminData.username,
      adminData.email,
      adminData.password,
      adminData.access_level,
    ]
  );

  // Create test category
  await pool.query(
    "INSERT INTO categories (id, name, description) VALUES ($1, $2, $3)",
    [uuidv4(), "Test Category", "Test Description"]
  );

  adminToken = jwt.sign(
    {
      username: adminData.username,
      email: adminData.email,
      access_level: true,
    },
    process.env.JWT_SECRET
  );

  // Create regular user
  const userData = {
    username: "user",
    email: "user@test.com",
    password: "User123",
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [uuidv4(), userData.username, userData.email, userData.password]
  );

  userToken = jwt.sign(
    { username: userData.username, email: userData.email },
    process.env.JWT_SECRET
  );
});

afterAll(async () => {
  await pool.query("TRUNCATE users, categories CASCADE");
  await pool.end();
});

describe("Category Management", () => {
  describe("GET /categories", () => {
    it("returns all categories", async () => {
      const response = await request(app).get("/categories");

      expect(response.status).toBe(200);
      expect(response.body[0].name).toBe("Test Category");
    });
  });

  describe("POST /categories", () => {
    it("allows admin to create category", async () => {
      const response = await request(app)
        .post("/categories")
        .set("Cookie", [`token=${adminToken}`])
        .send({
          name: "New Category",
          description: "New Description",
        });

      expect(response.status).toBe(201);
    });

    it("prevents non-admin from creating category", async () => {
      const response = await request(app)
        .post("/categories")
        .set("Cookie", [`token=${userToken}`])
        .send({
          name: "New Category",
          description: "New Description",
        });

      expect(response.status).toBe(403);
    });
  });
});

================
File: __tests_/integration/comments.test.js
================
// __tests__/integration/comments.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

describe("Comments Management", () => {
  let userId, photoId, authToken;
  const timestamp = Date.now();

  beforeAll(async () => {
    // Create test user with unique email
    userId = uuidv4();
    await pool.query(
      "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
      [
        userId,
        `testuser_${timestamp}`,
        `test_${timestamp}@test.com`,
        "hashedpassword",
      ]
    );

    // Create test photo
    photoId = uuidv4();
    await pool.query(
      "INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)",
      [
        photoId,
        userId,
        "Test Photo",
        "Test Description",
        "/test/path.jpg",
        true,
      ]
    );

    // Generate auth token
    authToken = jwt.sign(
      { id: userId, username: `testuser_${timestamp}` },
      process.env.JWT_SECRET
    );
  });

  afterAll(async () => {
    await pool.query("TRUNCATE users, photos, comments CASCADE");
    await pool.end();
  });

  describe("POST /comments/add/:photo_id", () => {
    it("adds comment successfully", async () => {
      const response = await request(app)
        .post(`/comments/add/${photoId}`)
        .set("Cookie", [`token=${authToken}`])
        .send({ content: "Test comment" });

      expect(response.status).toBe(201);
    });
  });

  describe("PUT /comments/edit/:comment_id", () => {
    it("allows user to edit own comment", async () => {
      // Create a comment first
      const commentId = uuidv4();
      await pool.query(
        "INSERT INTO comments (id, id_user, id_photo, content) VALUES ($1, $2, $3, $4)",
        [commentId, userId, photoId, "Original comment"]
      );

      const response = await request(app)
        .put(`/comments/edit/${commentId}`)
        .set("Cookie", [`token=${authToken}`])
        .send({ content: "Updated comment" });

      expect(response.status).toBe(200);
    });
  });

  // __tests__/integration/comments.test.js
  describe("GET /comments/photo/:p_id", () => {
    it("returns active photo comments", async () => {
      // Add a test comment first
      const commentId = uuidv4();
      await pool.query(
        "INSERT INTO comments (id, id_user, id_photo, content, status) VALUES ($1, $2, $3, $4, $5)",
        [commentId, userId, photoId, "Test comment", true]
      );

      const response = await request(app).get(`/comments/photo/${photoId}`);

      expect(response.status).toBe(201); // This matches the actual API response
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body[0].content).toBe("Test comment");
    });
  });
});

================
File: __tests_/integration/downloads.test.js
================
// __tests__/integration/downloads.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let authToken;
let testUser;
let testPhoto;

beforeAll(async () => {
  // Create test user with unique username
  const userId = uuidv4();
  const timestamp = Date.now();
  testUser = {
    id: userId,
    username: `testuser_${timestamp}`,
    email: `test_${timestamp}@test.com`,
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [userId, testUser.username, testUser.email, "hashedpassword"]
  );

  // Create test photo
  const photoId = uuidv4();
  testPhoto = {
    id: photoId,
    name: "Test Photo",
    path: "/test/path.jpg",
    description: "Test description",
  };

  await pool.query(
    "INSERT INTO photos (id, user_id, name, path, description, status) VALUES ($1, $2, $3, $4, $5, $6)",
    [
      photoId,
      userId,
      testPhoto.name,
      testPhoto.path,
      testPhoto.description,
      true,
    ]
  );

  authToken = jwt.sign(testUser, process.env.JWT_SECRET);
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos, downloads CASCADE");
  await pool.end();
});

describe("Downloads Management", () => {
  describe("POST /downloads/download/:id_photo", () => {
    it("adds download successfully", async () => {
      const response = await request(app)
        .post(`/downloads/download/${testPhoto.id}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(201);
    });
  });

  describe("GET /downloads/user/:u_id", () => {
    it("returns user downloads", async () => {
      const response = await request(app)
        .get(`/downloads/user/${testUser.id}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
    });
  });
});

================
File: __tests_/integration/likes.test.js
================
// __tests__/integration/likes.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let authToken;
let testPhotoId;

beforeAll(async () => {
  // Create test user
  const userId = uuidv4();
  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [userId, "testuser", "test@test.com", "password123"]
  );

  // Create test photo
  testPhotoId = uuidv4();
  await pool.query(
    "INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)",
    [testPhotoId, userId, "Test Photo", "Description", "path/to/photo", true]
  );

  // Create test like
  const likeId = uuidv4();
  await pool.query(
    "INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3)",
    [likeId, userId, testPhotoId]
  );

  authToken = jwt.sign(
    { id: userId, username: "testuser" },
    process.env.JWT_SECRET
  );
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos, likes CASCADE");
  await pool.end();
});

describe("Like Management", () => {
  describe("GET /likes/photo/:p_id", () => {
    it("returns photo likes count", async () => {
      const response = await request(app).get(`/likes/likes/${testPhotoId}`);

      expect(response.status).toBe(200);
      expect(response.body[0]).toHaveProperty("count");
      expect(parseInt(response.body[0].count)).toBe(1);
    });
  });

  describe("POST /likes/like/:id_photo", () => {
    it("prevents duplicate likes", async () => {
      const response = await request(app)
        .post(`/likes/like/${testPhotoId}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty("warning");
    });
  });
});

================
File: __tests_/integration/photo.test.js
================
// __tests__/integration/photo.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");

let authToken;
let testUser;

beforeAll(async () => {
  // Create test user
  const userData = {
    username: "testuser",
    email: "test@example.com",
    password: "Test123",
  };

  const registerResponse = await request(app)
    .post("/user/register")
    .send(userData);

  authToken = registerResponse.body.token;
  testUser = registerResponse.body.user;
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos CASCADE");
  await pool.end();
});

describe("Photo Management", () => {
  describe("Photo Creation", () => {
    const testPhoto = {
      name: "Test Photo",
      description: "Test Description",
      path: "https://example.com/test.jpg",
      status: true,
    };

    it("should create a new photo successfully", async () => {
      const response = await request(app)
        .post("/photos/add_photo")
        .set("Cookie", [`token=${authToken}`])
        .send(testPhoto);

      expect(response.status).toBe(201);
    });

    it("should reject photo creation without auth", async () => {
      const response = await request(app)
        .post("/photos/add_photo")
        .send(testPhoto);

      expect(response.status).toBe(401);
    });
  });

  describe("Photo Retrieval", () => {
    it("should get active photos", async () => {
      const response = await request(app).get("/photos/photos");

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
    });
  });
});

================
File: __tests_/integration/user.test.js
================
// __tests__/integration/user.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
require("dotenv").config();

describe("User Management", () => {
  let userId;
  let authToken;

  beforeAll(async () => {
    await pool.query("TRUNCATE users CASCADE");

    // Create test user directly in database
    userId = "550e8400-e29b-41d4-a716-446655440000";
    await pool.query(
      "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
      [userId, "testuser", "test@test.com", "hashedpassword"]
    );

    // Generate auth token
    authToken = jwt.sign(
      { id: userId, username: "testuser", email: "test@test.com" },
      process.env.JWT_SECRET
    );
  });

  afterAll(async () => {
    await pool.end();
  });

  describe("Profile Management", () => {
    it("updates profile successfully", async () => {
      const updatedProfile = {
        username: "updateduser",
        user_icon: "https://example.com/newicon.jpg",
      };

      const response = await request(app)
        .put(`/user/changeuser/${userId}`)
        .set("Cookie", [`token=${authToken}`])
        .send(updatedProfile);

      expect(response.status).toBe(200);
    });
  });
});

================
File: __tests_/setup/testDb.js
================
// __tests__/setup/testDb.js
const { pool } = require("../../utils/db");

async function cleanDatabase() {
  await pool.query(
    "TRUNCATE users, photos, comments, likes, downloads, categories CASCADE"
  );
}

async function seedTestData() {
  // Create test admin user
  const adminUser = await pool.query(
    `
    INSERT INTO users (id, username, email, password, access_level)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING *`,
    [
      "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "admin",
      "admin@test.com",
      "$2a$10$fakehashedpassword",
      true,
    ]
  );

  // Create test regular user
  const regularUser = await pool.query(
    `
    INSERT INTO users (id, username, email, password)
    VALUES ($1, $2, $3, $4)
    RETURNING *`,
    [
      "b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "user",
      "user@test.com",
      "$2a$10$fakehashedpassword",
    ]
  );

  // Create test category
  const category = await pool.query(
    `
    INSERT INTO categories (id, name, description)
    VALUES ($1, $2, $3)
    RETURNING *`,
    [
      "c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "Test Category",
      "Test Description",
    ]
  );

  // Create test photo
  const photo = await pool.query(
    `
    INSERT INTO photos (id, user_id, name, description, path, status)
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING *`,
    [
      "d0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      regularUser.rows[0].id,
      "Test Photo",
      "Test Photo Description",
      "https://example.com/test.jpg",
      true,
    ]
  );

  return {
    adminUser: adminUser.rows[0],
    regularUser: regularUser.rows[0],
    category: category.rows[0],
    photo: photo.rows[0],
  };
}

module.exports = {
  cleanDatabase,
  seedTestData,
};

================
File: .gitignore
================
# Node modules
node_modules/

# Environment variables
.env

================
File: controllers/CategoriesController.js
================
const { v4: uuidv4 } = require("uuid");
const categoryModel = require("../models/CategoriesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");

async function showCategories(req, res) {
  try {
    const result = await categoryModel.getCategories();
    res.send(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showCategoryById(req, res) {
  const id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const result = await categoryModel.getCategoryById(id);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid UUID" });
  }
}

async function showCategoryByName(req, res) {
  const name = sanitizeHtml(req.params.name);
  if (name && typeof name === "string") {
    try {
      const result = await categoryModel.getCategoryByName(name);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid name format" });
  }
}

async function createCategory(req, res) {
  // Check if user has admin access (belt and suspenders, since middleware also checks)
  if (!req.user || !req.user.access_level) {
    return res.status(403).json({ error: "Admin access required" });
  }

  let { name, description } = req.body;
  const id = uuidv4();
  let sanitizedName = sanitizeHtml(name);
  let sanitizedDescription = sanitizeHtml(description);

  if (validator.isUUID(id) && name && description) {
    try {
      await categoryModel.createCategory(
        id,
        sanitizedName,
        sanitizedDescription
      );
      res.status(201).json({ message: "Category created successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to create category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

/* Edit category, admin only */
async function editCategory(req, res) {
  const id = sanitizeHtml(req.params.id);
  let { name, description } = req.body;

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);

  if (
    validator.isUUID(id) &&
    name &&
    name.trim() !== "" &&
    description &&
    description.trim() !== ""
  ) {
    try {
      await categoryModel.editCategory(id, name, description);
      res.status(200).json({ message: "Category edited successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to edit category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

async function deleteCategory(req, res) {
  const id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      await categoryModel.deleteCategory(id);
      res.status(200).json({ message: "Category deleted successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to delete category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid category ID" });
  }
}

module.exports = {
  showCategories,
  createCategory,
  showCategoryById,
  showCategoryByName,
  editCategory,
  deleteCategory,
};

================
File: controllers/CommentsController.js
================
const commentsModel = require("../models/CommentsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function showAllPhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getAllPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function addComment(req, res) {
  const photo_id = sanitizeHtml(req.params.photo_id);
  const { content } = req.body;
  const user_id = req.user.id;
  const id = uuidv4();

  if (!validator.isUUID(photo_id) || !content || content.trim() === "") {
    return res.status(400).json({ error: "Invalid input data" });
  }

  try {
    const photoStatus = await commentsModel.getPhotoStatus(photo_id);

    if (photoStatus.rows.length === 0) {
      return res.status(404).json({ error: "Photo not found" });
    }

    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot comment on inactive photos" });
    }

    const result = await commentsModel.addComment(
      id,
      user_id,
      photo_id,
      content
    );
    res.status(201).json({
      message: "Comment added successfully",
      comment: result.rows[0],
    });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to add comment", details: err.message });
  }
}

async function editComment(req, res) {
  const comment_id = sanitizeHtml(req.params.comment_id);
  const { content } = req.body;
  const user_id = req.user.id;

  if (!validator.isUUID(comment_id) || !content || content.trim() === "") {
    return res.status(400).json({ error: "Invalid input data" });
  }

  try {
    const commentResult = await commentsModel.getCommentDetails(comment_id);

    if (commentResult.rows.length === 0) {
      return res.status(404).json({ error: "Comment not found" });
    }

    const comment = commentResult.rows[0];

    if (comment.id_user !== user_id) {
      return res
        .status(403)
        .json({ error: "Not authorized to edit this comment" });
    }

    const photoStatus = await commentsModel.getPhotoStatus(comment.id_photo);
    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot edit comment on inactive photo" });
    }

    const result = await commentsModel.edtiComment(
      comment_id,
      user_id,
      content
    );
    res.status(200).json({
      message: "Comment updated successfully",
      comment: result.rows[0],
    });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to update comment", details: err.message });
  }
}

// Only showing the updated deleteComment function since it's the only one that needs admin logic
async function deleteComment(req, res) {
  let comment_id = sanitizeHtml(req.params.id);
  const user_id = req.user.id;
  const isAdmin = req.user.access_level; // From your JWT token

  if (!validator.isUUID(comment_id)) {
    return res.status(400).json({ error: "Invalid comment ID" });
  }

  try {
    // Check if comment exists and get its details
    const commentResult = await commentsModel.getCommentDetails(comment_id);

    if (commentResult.rows.length === 0) {
      return res.status(404).json({ error: "Comment not found" });
    }

    const comment = commentResult.rows[0];

    // Allow deletion if user is admin or comment owner
    if (!isAdmin && comment.id_user !== user_id) {
      return res
        .status(403)
        .json({ error: "Not authorized to delete this comment" });
    }

    // Check if photo is still active
    const photoStatus = await commentsModel.getPhotoStatus(comment.id_photo);
    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot delete comment on inactive photo" });
    }

    await commentsModel.deleteComment(
      comment_id,
      isAdmin ? comment.id_user : user_id
    );
    res.status(200).json({ message: "Comment deleted successfully" });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to delete comment", details: err.message });
  }
}

module.exports = {
  showActivePhotoComments,
  showAllPhotoComments,
  addComment,
  editComment,
  deleteComment,
};

================
File: controllers/DownloadsController.js
================
const downloadsModel = require("../models/DownloadsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function checkDownloads(id_user, id_photo) {
  try {
    const result = await downloadsModel.getAllDownloads();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    console.log(err);
    throw err;
  }
}

async function addDownload(req, res) {
  let id_photo = req.params.id_photo;
  const id_user = req.user.id;
  id_photo = sanitizeHtml(id_photo);
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkDownloads(id_user, id_photo);
      if (check === true) {
        res
          .status(200)
          .json({ warning: "You have already downloaded this photo!" });
      } else {
        await downloadsModel.addDownload(id, id_user, id_photo);
        res
          .status(201)
          .json({ message: "Download added to library successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUserDownloads(req, res) {
  let u_id = req.params.u_id;
  u_id = sanitizeHtml(u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these downloads" });
    }
    try {
      const result = await downloadsModel.getUserDownloads(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

module.exports = {
  showUserDownloads,
  addDownload,
};

================
File: controllers/LikesController.js
================
const likesModel = require("../models/LikesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.countPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function getUserLikes(req, res) {
  let u_id = sanitizeHtml(req.params.u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these likes" });
    }
    try {
      const result = await likesModel.getUserLikes(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

async function getPhotoLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.getPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function checkLikes(id_user, id_photo) {
  try {
    const result = await likesModel.getAllLikes();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    throw err;
  }
}

async function addLike(req, res) {
  const id_photo = sanitizeHtml(req.params.id_photo);
  const id_user = req.user.id;
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        res.status(200).json({ warning: "You have already liked this photo!" });
      } else {
        await likesModel.likePhoto(id, id_user, id_photo);
        res.status(201).json({ message: "Like added successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deleteLike(req, res) {
  let { id_photo } = req.params;
  const id_user = req.user.id; // Get user id from the authenticated token
  id_photo = sanitizeHtml(id_photo);
  if (validator.isUUID(id_user) && validator.isUUID(id_photo)) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        await likesModel.unlikePhoto(id_user, id_photo);
        res.status(200).json({ message: "Photo unliked!" });
      } else {
        res.status(200).json({ warning: "You have not liked this photo!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showLikes,
  getUserLikes,
  getPhotoLikes,
  addLike,
  deleteLike,
};

================
File: controllers/PhotoController.js
================
const photoModel = require("../models/PhotoModel");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotos(req, res) {
  try {
    const result = await photoModel.getActivePhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhotos(req, res) {
  try {
    const result = await photoModel.getPhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getPhoto(id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotos(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getUserPhotos(id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotoById(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  let u_id = sanitizeHtml(req.params.u_id);

  if (validator.isUUID(p_id) && validator.isUUID(u_id)) {
    try {
      const result = await photoModel.getUserPhotoById(p_id, u_id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function newPhoto(req, res) {
  let { name, description, path, status } = req.body;
  let user_id = req.user.id; // Get user id from the authenticated token
  let id = uuidv4();

  if (
    status === undefined ||
    status === "" ||
    status === null ||
    path === undefined ||
    path === null ||
    path === ""
  ) {
    status = false;
  }

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);
  path = sanitizeHtml(path);

  if (
    validator.isUUID(user_id) &&
    validator.isUUID(id) &&
    (validator.isURL(path) ||
      path === "" ||
      path === null ||
      path === undefined) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      await photoModel.createPhoto(
        id,
        user_id,
        name,
        description,
        path,
        status
      );
      res.status(201).json({ message: `Photo ${name} created successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deletePhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to delete this photo" });
      }
      await photoModel.deletePhoto(id);
      res.status(200).json({ message: `Photo deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function editPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  let { name, description, status } = req.body;

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);

  if (
    validator.isUUID(id) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to edit this photo" });
      }
      await photoModel.editPhoto(name, description, status, id);
      res.status(200).json({ message: `Photo updated successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showActivePhotos,
  showPhotos,
  showPhoto,
  showUserPhotos,
  showUserPhotoById,
  newPhoto,
  deletePhoto,
  editPhoto,
};

================
File: controllers/UserController.js
================
const userModel = require("../models/UserModel");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const secret = process.env.JWT_SECRET;
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

// Token generation
function generateToken(user) {
  return jwt.sign(
    {
      id: user.id,
      username: user.username,
      email: user.email,
      access_level: user.access_level,
    },
    secret,
    { expiresIn: "30d" }
  );
}

async function loginUser(req, res) {
  let { email, password } = req.body;
  email = sanitizeHtml(email);
  password = sanitizeHtml(password);

  if (validator.isEmail(email) && validator.isAlphanumeric(password)) {
    try {
      const user = await userModel.getUserByEmail(email);
      if (user.rows.length === 0) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const isMatch = await bcrypt.compare(password, user.rows[0].password);
      if (!isMatch) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = jwt.sign(
        {
          id: user.rows[0].id,
          username: user.rows[0].username,
          email: user.rows[0].email,
          access_level: user.rows[0].access_level, // Add access_level to token payload
        },
        secret,
        { expiresIn: "30d" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
        sameSite: "strict", // Added security measure
      });

      res.status(200).json({
        message: "Login successful",
        token: token,
      });
    } catch (err) {
      res.status(500).json({ error: "Internal server error" });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUsers(req, res) {
  try {
    const result = await userModel.getUsers();
    res.send(result.rows);
  } catch (err) {
    res.send(err);
  }
}

async function showUser(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUser(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUsername(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUsername(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUserByEmail(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    try {
      const result = await userModel.getUserByEmail(email);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  }
}

async function registerUser(req, res) {
  let { username, password, email, user_icon } = req.body;
  const id = uuidv4();
  username = sanitizeHtml(username);
  password = sanitizeHtml(password);
  email = sanitizeHtml(email);
  user_icon = sanitizeHtml(user_icon);

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    validator.isEmail(email) &&
    validator.isAlphanumeric(password) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      const salt = bcrypt.genSaltSync(10);
      const hash = bcrypt.hashSync(password, salt);

      await userModel.newUser(id, username, email, hash, user_icon);

      const user = { id, email, username };
      const token = generateToken(user);

      res.status(201).json({
        message: `User ${email} created successfully!`,
        token,
        user,
      });
    } catch (err) {
      if (err.code === "23505") {
        res.status(400).json({ message: `Email or username already exists!` });
      } else if (err.code === "22P02") {
        res.status(400).json({ message: `Invalid data!` });
      } else {
        console.error(err);
        res
          .status(500)
          .json({ error: "Internal server error", details: err.message });
      }
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function delUser(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    if (email !== req.user.email) {
      return res
        .status(403)
        .json({ error: "Not authorized to delete this user" });
    }
    try {
      await userModel.deleteUser(email);
      res.clearCookie("token");
      res.status(200).json({ message: `User ${email} deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid email format" });
  }
}

// need to validate using jwt and compare hashed password / id / email / username
async function changePass(req, res) {
  let { email, currentPassword, newPassword } = req.body;

  email = sanitizeHtml(email);
  currentPassword = sanitizeHtml(currentPassword);
  newPassword = sanitizeHtml(newPassword);

  if (email !== req.user.email) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's password" });
  }

  if (
    !validator.isEmail(email) ||
    !validator.isAlphanumeric(currentPassword) ||
    !validator.isAlphanumeric(newPassword)
  ) {
    return res.status(400).json({ error: "Invalid data!" });
  }

  try {
    const user = await userModel.getUserByEmail(email);
    if (user.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const isMatch = await bcrypt.compare(
      currentPassword,
      user.rows[0].password
    );
    if (!isMatch) {
      return res.status(401).json({ error: "Current password is incorrect" });
    }

    const salt = bcrypt.genSaltSync(10);
    const hash = bcrypt.hashSync(newPassword, salt);

    await userModel.editPassword(hash, email);
    res.status(200).json({ message: "Password updated successfully!" });
  } catch (err) {
    console.error("Error in changePass:", err);
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

// validation needed here also
async function changeUser(req, res) {
  let { username, user_icon } = req.body;
  let id = req.params.id;

  username = sanitizeHtml(username);
  user_icon = sanitizeHtml(user_icon);

  if (id !== req.user.id) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's information" });
  }

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      await userModel.editUser(username, user_icon, id);
      res.status(200).json({ message: "User updated successfully!" });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function logoutUser(req, res) {
  try {
    // Clear the JWT cookie
    res.clearCookie("token");
    res.status(200).json({ message: "Logged out successfully" });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

module.exports = {
  showUsers,
  showUser,
  showUsername,
  registerUser,
  showUserByEmail,
  delUser,
  changePass,
  changeUser,
  loginUser,
  logoutUser,
};

================
File: index.js
================
const express = require("express");
const app = express();
const cors = require("cors");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const cookieParser = require("cookie-parser"); // Add this line
const userRoute = require("./routes/userRoute");
const photoRoute = require("./routes/photoRoute");
const categoriesRoute = require("./routes/categoriesRoute");
const likesRoute = require("./routes/likesRoute");
const downloadsRoute = require("./routes/downloadsRoute");
const commentsRoute = require("./routes/commentsRoute");

app.use(express.json());
app.use(helmet());
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true, // Allows cookies with CORS
  })
);
app.use(cookieParser()); // Uses the cookie parser

const limiter = rateLimit({
  windowsMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per `window` (here, per 15 minutes)
});

app.use(limiter);

app.use("/user", userRoute);
app.use("/photos", photoRoute);
app.use("/categories", categoriesRoute);
app.use("/likes", likesRoute);
app.use("/downloads", downloadsRoute);
app.use("/comments", commentsRoute);

// app.listen(3000, () => {
//   console.log("Server is running on port 3000");
// });

if (process.env.NODE_ENV !== "test") {
  app.listen(3000, () => {
    console.log("Server is running on port 3000");
  });
}

module.exports = app;

================
File: middleware/authMiddleware.js
================
const jwt = require("jsonwebtoken");
require("dotenv").config();

const authMiddleware = (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ error: "Token expired" });
    }
    return res.status(401).json({ error: "Invalid token" });
  }
};

const isAdmin = (req, res, next) => {
  if (!req.user || !req.user.access_level) {
    return res.status(403).json({ error: "Admin access required" });
  }
  next();
};

module.exports = { authMiddleware, isAdmin };

================
File: models/CategoriesModel.js
================
const { pool } = require("../utils/db");

function getCategories() {
  return pool.query(`SELECT * FROM categories`);
}

/* Untested functionality */
function getCategoryById(id) {
  return pool.query(`SELECT * FROM categories WHERE id = $1`, [id]);
}

/* Untested functionality */
function getCategoryByName(name) {
  return pool.query(`SELECT * FROM categories WHERE name = $1`, [name]);
}

/* Untested functionality */
function createCategory(id, name, description) {
  return pool.query(
    `INSERT INTO categories (id, name, description) VALUES ($1, $2, $3) RETURNING (id, name)`,
    [id, name, description]
  );
}

/* Edit category, admin only */
function editCategory(id, name, description) {
  return pool.query(
    `UPDATE categories SET name = $1, description = $2 WHERE id = $3 RETURNING (id, name)`,
    [id, name, description]
  );
}

/* Delete category, admin only */
function deleteCategory(id) {
  return pool.query("DELETE FROM categories WHERE id = $1 RETURNING id", [id]);
}

module.exports = {
  getCategories,
  createCategory,
  getCategoryById,
  getCategoryByName,
  editCategory,
  deleteCategory,
};

================
File: models/CommentsModel.js
================
const { pool } = require("../utils/db");

function getPhotoComments(p_id) {
  return pool.query(
    `SELECT * FROM comments WHERE id_photo = $1 AND status = true`,
    [p_id]
  );
}

function getAllPhotoComments(p_id) {
  return pool.query(`SELECT * FROM comments WHERE id_photo = $1`, [p_id]);
}

function addComment(id, user_id, photo_id, content) {
  return pool.query(
    `INSERT INTO comments (id, id_user, id_photo, content) VALUES ($1, $2, $3, $4) RETURNING (id, id_photo)`,
    [id, user_id, photo_id, content]
  );
}

function deleteComment(comment_id, user_id) {
  return pool.query(
    `DELETE FROM comments WHERE id = $1 AND id_user = $2 RETURNING (id)`,
    [comment_id, user_id]
  );
}

function edtiComment(comment_id, user_id, content) {
  return pool.query(
    `UPDATE comments SET content = $1 WHERE id = $2 AND id_user = $3 RETURNING (id)`,
    [content, comment_id, user_id]
  );
}

// Helper function to check if the photo is active or not
function getPhotoStatus(photo_id) {
  return pool.query(`SELECT status FROM photos WHERE id = $1`, [photo_id]);
}

// Helper function to get details of comments
function getCommentDetails(comment_id) {
  return pool.query(`SELECT * FROM comments WHERE id = $1`, [comment_id]);
}

module.exports = {
  getPhotoComments,
  getAllPhotoComments,
  addComment,
  deleteComment,
  edtiComment,
  getPhotoStatus,
  getCommentDetails,
};

================
File: models/DownloadsModel.js
================
const { pool } = require("../utils/db");

function getUserDownloads(u_id) {
  return pool.query(
    `
        SELECT * FROM downloads
        JOIN photos ON downloads.id_photo = photos.id
        WHERE id_user = $1`,
    [u_id]
  );
}

function addDownload(id, u_id, p_id) {
  return pool.query(
    `INSERT INTO downloads (id, id_user, id_photo) VALUES ($1, $2, $3) RETURNING (id_photo)`,
    [id, u_id, p_id]
  );
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllDownloads() {
  return pool.query(`SELECT id_user, id_photo FROM downloads`);
}

module.exports = {
  getUserDownloads,
  addDownload,
  getAllDownloads,
};

================
File: models/LikesModel.js
================
const { pool } = require("../utils/db");

/* Returns all the photos the user has liked */
/* Change star to specific fields due to memory leaks! */
function getUserLikes(u_id) {
  return pool.query(
    `
        SELECT * FROM likes l
        JOIN photos p ON l.id_photo = p.id
        WHERE l.id_user = $1`,
    [u_id]
  );
}

/* Should return the username of people that liked the photo */
/* Change star to specific fields due to memory leaks! */
function getPhotoLikes(p_id) {
  return pool.query(
    `
        SELECT u.id, u.username, u.user_icon, l.id, l.id_photo FROM likes l
        JOIN users u ON l.id_user = u.id
        WHERE l.id_photo = $1`,
    [p_id]
  );
}

/* Returns the number of likes on a specific photo */
function countPhotoLikes(p_id) {
  return pool.query(
    `SELECT COUNT(*) FROM likes l
    JOIN photos p ON l.id_photo = p.id
    WHERE l.id_photo = $1`,
    [p_id]
  );
}

/* Unlike photo */
function unlikePhoto(u_id, p_id) {
  return pool.query(
    `DELETE FROM likes WHERE id_user = $1 AND id_photo = $2 RETURNING (id_photo)`,
    [u_id, p_id]
  );
}

/* Like photo */
function likePhoto(id, u_id, p_id) {
  return pool.query(
    `INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3) RETURNING (id_photo)`,
    [id, u_id, p_id]
  );
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllLikes() {
  return pool.query(`SELECT id_user, id_photo FROM likes`);
}

module.exports = {
  getUserLikes,
  getPhotoLikes,
  countPhotoLikes,
  likePhoto,
  getAllLikes,
  unlikePhoto,
};

================
File: models/PhotoModel.js
================
const { pool } = require("../utils/db");

function getActivePhotos() {
  return pool.query("SELECT * FROM photos WHERE status = true");
}

function getPhotos() {
  return pool.query("SELECT * FROM photos");
}

function getPhoto(id) {
  const req = `SELECT * FROM photos WHERE id = $1`;
  return pool.query(req, [id]);
}

function getUserPhotos(id) {
  const req = `SELECT * FROM photos WHERE user_id = $1`;
  return pool.query(req, [id]);
}

function getUserPhotoById(p_id, u_id) {
  const req = `SELECT * FROM photos WHERE id = $1 AND user_id = $2`;
  return pool.query(req, [p_id, u_id]);
}

function createPhoto(id, user_id, name, description, path, status) {
  const req = `INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6) RETURNING (id, name)`;
  return pool.query(req, [id, user_id, name, description, path, status]);
}

function deletePhoto(id) {
  const req = `DELETE FROM photos WHERE id = $1 RETURNING id`;
  return pool.query(req, [id]);
}

function editPhoto(name, description, status, id) {
  const req = `UPDATE photos SET name = $1, description = $2, status = $3 WHERE id = $4 RETURNING (id, name)`;
  return pool.query(req, [name, description, status, id]);
}

module.exports = {
  getActivePhotos,
  getPhotos,
  getPhoto,
  getUserPhotos,
  getUserPhotoById,
  createPhoto,
  deletePhoto,
  editPhoto,
};

================
File: models/UserModel.js
================
const { pool } = require("../utils/db");

function getUsers() {
  return pool.query(`SELECT * FROM users`);
}

function getUser(id) {
  const req = `SELECT * FROM users WHERE id = $1`;
  return pool.query(req, [id]);
}

function getUserByEmail(email) {
  const req = `SELECT * FROM users WHERE email = $1`;
  return pool.query(req, [email]);
}

function getUsername(id) {
  const req = `SELECT username FROM users WHERE id = $1`;
  return pool.query(req, [id]);
}

function newUser(id, username, email, password, user_icon) {
  const req = `INSERT INTO users (id, username, email, password, user_icon) VALUES ($1, $2, $3, $4, $5) RETURNING (username)`;
  return pool.query(req, [id, username, email, password, user_icon]);
}

function deleteUser(email) {
  const req = `DELETE FROM users WHERE email = $1 RETURNING (username)`;
  return pool.query(req, [email]);
}

function editUser(username, user_icon, id) {
  const req = `UPDATE users SET username = $1, user_icon = $2 WHERE id = $3 RETURNING (username)`;
  return pool.query(req, [username, user_icon, id]);
}

async function editPassword(password, email) {
  const req = `UPDATE users SET password = $1 WHERE email = $2 RETURNING (username)`;
  return pool.query(req, [password, email]);
}

module.exports = {
  getUsers,
  getUser,
  getUsername,
  newUser,
  getUserByEmail,
  deleteUser,
  editUser,
  editPassword,
};

================
File: package.json
================
{
  "name": "photostockage-backend",
  "version": "0.0.1",
  "description": "Backend for a project for my training at m2i",
  "main": "index.js",
  "scripts": {
    "test": "set NODE_ENV=test&& jest --runInBand --detectOpenHandles --forceExit"
  },
  "keywords": [
    "backend",
    "node",
    "nodejs"
  ],
  "author": "Sigmund Frost",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "sanitize-html": "^2.13.0",
    "sequelize": "^6.37.3",
    "uuidv4": "^6.2.13",
    "validator": "^13.12.0"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "supertest": "^7.0.0"
  }
}

================
File: routes/categoriesRoute.js
================
const express = require("express");
const categoriesRouter = express.Router();
const categoriesController = require("../controllers/CategoriesController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* Public routes */
categoriesRouter.get("/", categoriesController.showCategories);
categoriesRouter.get("/:id", categoriesController.showCategoryById);
categoriesRouter.get("/name/:name", categoriesController.showCategoryByName);

/* Admin only routes */
categoriesRouter.post(
  "/",
  authMiddleware,
  isAdmin,
  categoriesController.createCategory
);
categoriesRouter.put(
  "/edit/:id",
  authMiddleware,
  isAdmin,
  categoriesController.editCategory
);
categoriesRouter.delete(
  "/delete/:id",
  authMiddleware,
  isAdmin,
  categoriesController.deleteCategory
);

module.exports = categoriesRouter;

================
File: routes/commentsRoute.js
================
const express = require("express");
const commentsRouter = express.Router();
const commentsController = require("../controllers/CommentsController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* Public routes */
commentsRouter.get("/photo/:p_id", commentsController.showActivePhotoComments);
commentsRouter.get("/c_photo/:p_id", commentsController.showAllPhotoComments);

/* Protected routes - require authentication */
// Add new comment
commentsRouter.post(
  "/add/:photo_id",
  authMiddleware,
  commentsController.addComment
);

// Edit comment
commentsRouter.put(
  "/edit/:comment_id",
  authMiddleware,
  commentsController.editComment
);

// Delete comment (accessible by comment owner or admin)
commentsRouter.delete(
  "/delete/:id",
  authMiddleware,
  commentsController.deleteComment
);

module.exports = commentsRouter;

================
File: routes/downloadsRoute.js
================
const express = require("express");
const downloadsRouter = express.Router();
const downloadsController = require("../controllers/DownloadsController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
downloadsRouter.get(
  "/user/:u_id",
  authMiddleware,
  downloadsController.showUserDownloads
);

/* method: POST */
downloadsRouter.post(
  "/download/:id_photo",
  authMiddleware,
  downloadsController.addDownload
);

module.exports = downloadsRouter;

================
File: routes/likesRoute.js
================
const express = require("express");
const likesRouter = express.Router();
const likesController = require("../controllers/LikesController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
likesRouter.get("/likes/:p_id", likesController.showLikes);
likesRouter.get("/user/:u_id", authMiddleware, likesController.getUserLikes);
likesRouter.get("/photo/:p_id", likesController.getPhotoLikes);

/* method: POST */
likesRouter.post("/like/:id_photo", authMiddleware, likesController.addLike);

/* method: DELETE */
likesRouter.delete(
  "/like/:id_photo",
  authMiddleware,
  likesController.deleteLike
);

module.exports = likesRouter;

================
File: routes/photoRoute.js
================
const express = require("express");
const photoRouter = express.Router();
const photoController = require("../controllers/PhotoController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
photoRouter.get("/photos/admin", photoController.showPhotos);
photoRouter.get("/photos", photoController.showActivePhotos);
photoRouter.get("/photo/:id", photoController.showPhoto);
photoRouter.get("/photos/user/:id", photoController.showUserPhotos);
photoRouter.get("/photo/user/:p_id/:u_id", photoController.showUserPhotoById);

/* method: POST */
photoRouter.post("/add_photo", authMiddleware, photoController.newPhoto);

/* method: DELETE */
photoRouter.delete("/delete/:id", authMiddleware, photoController.deletePhoto);

/* method: PUT */
photoRouter.put("/edit/:id", authMiddleware, photoController.editPhoto);

module.exports = photoRouter;

================
File: routes/userRoute.js
================
const express = require("express");
const userRouter = express.Router();
const userController = require("../controllers/UserController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
userRouter.get("/users", userController.showUsers);
userRouter.get("/user/:id", userController.showUser);
userRouter.get("/username/:id", userController.showUsername);
userRouter.get("/email/:email", userController.showUserByEmail);

/* method: POST */
userRouter.post("/register", userController.registerUser);
userRouter.post("/login", userController.loginUser);
userRouter.post("/logout", authMiddleware, userController.logoutUser);

/* method: DELETE */
userRouter.delete("/delete/:email", authMiddleware, userController.delUser);

/* method: PUT */
userRouter.put("/changepass", authMiddleware, userController.changePass);
userRouter.put("/changeuser/:id", authMiddleware, userController.changeUser);

module.exports = userRouter;

================
File: Tests.md
================
# Jest Testing Guide for PhotoStockage Backend

## Introduction

This guide explains the test structure and implementation for our Node.js backend application using Jest and Supertest.

## Test Organization

### Directory Structure

```
__tests__/
 integration/
    user.test.js
    comments.test.js
    likes.test.js
    photos.test.js
    downloads.test.js
 setup/
     testDb.js
```

### Key Components

- **Jest**: Testing framework
- **Supertest**: HTTP assertions library
- **Pool**: PostgreSQL connection pool
- **JWT**: JSON Web Tokens for authentication

## Test Setup Explained

```javascript
// Basic test file structure
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

describe("Feature Group", () => {
  // Setup before tests
  beforeAll(async () => {
    // Database setup code
  });

  // Cleanup after tests
  afterAll(async () => {
    // Database cleanup code
  });

  describe("Specific Feature", () => {
    // Individual test cases
  });
});
```

### Important Concepts

#### 1. Test Lifecycle Hooks

- `beforeAll`: Runs once before all tests
- `afterAll`: Runs once after all tests
- `beforeEach`: Runs before each test
- `afterEach`: Runs after each test

```javascript
beforeAll(async () => {
  // Create test user
  const userId = uuidv4();
  await pool.query(
    "INSERT INTO users (id, username, email) VALUES ($1, $2, $3)",
    [userId, "testuser", "test@test.com"]
  );
});
```

#### 2. Test Structure

```javascript
describe("Feature", () => {
  it("should do something specific", async () => {
    // Arrange (setup)
    const testData = {
      /* ... */
    };

    // Act (perform action)
    const response = await request(app).post("/endpoint").send(testData);

    // Assert (verify results)
    expect(response.status).toBe(200);
  });
});
```

#### 3. Authentication Testing

```javascript
// Generate auth token for testing
const authToken = jwt.sign(
  { id: userId, username: "testuser" },
  process.env.JWT_SECRET
);

// Use token in requests
const response = await request(app)
  .post("/protected-endpoint")
  .set("Cookie", [`token=${authToken}`])
  .send(data);
```

## Common Jest Assertions

```javascript
// Status codes
expect(response.status).toBe(200);

// Response body
expect(response.body).toHaveProperty("token");
expect(Array.isArray(response.body)).toBe(true);
expect(response.body.message).toContain("success");

// Database checks
const dbResult = await pool.query("SELECT * FROM users WHERE id = $1", [
  userId,
]);
expect(dbResult.rows).toHaveLength(1);
```

## Database Testing

### Setup and Cleanup

```javascript
// Clear tables
await pool.query("TRUNCATE users CASCADE");

// Add test data
await pool.query("INSERT INTO users (...) VALUES (...)");

// Cleanup
await pool.end();
```

## Error Testing

```javascript
it("should handle invalid input", async () => {
  const response = await request(app)
    .post("/endpoint")
    .send({ invalid: "data" });

  expect(response.status).toBe(400);
  expect(response.body).toHaveProperty("error");
});
```

## Test Examples

### User Registration Test

```javascript
describe("User Registration", () => {
  it("registers new user successfully", async () => {
    const userData = {
      username: `testuser_${Date.now()}`,
      email: `test_${Date.now()}@test.com`,
      password: "Test123",
    };

    const response = await request(app).post("/user/register").send(userData);

    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty("token");
  });
});
```

### Protected Route Test

```javascript
describe("Protected Routes", () => {
  it("requires authentication", async () => {
    const response = await request(app).get("/protected-route");

    expect(response.status).toBe(401);
  });

  it("allows access with valid token", async () => {
    const response = await request(app)
      .get("/protected-route")
      .set("Cookie", [`token=${validToken}`]);

    expect(response.status).toBe(200);
  });
});
```

## Running Tests

```bash
# Run all tests
npm test

# Run specific test file
npm test -- __tests__/integration/user.test.js

# Run tests in watch mode
npm run test:watch
```

## Best Practices

1. Use unique identifiers (timestamps, UUIDs) for test data
2. Clean up database after tests
3. Test both success and error cases
4. Keep tests independent
5. Use meaningful test descriptions
6. Mock external services when necessary
7. Test API endpoints with different authentication states
8. Verify database state after operations
9. Use appropriate timeout values for async operations
10. Follow the Arrange-Act-Assert pattern

## Common Pitfalls

- Not handling async operations properly
- Database connection leaks
- Dependency on test order
- Missing error cases
- Hardcoded test data
- Not cleaning up test data
- Inadequate authentication testing

================
File: todo
================
add message if return.rows is emtpy
add message for errors
implement tokens
implement bcrypt for users controller
add requests to postman

================
File: todo.md
================
# Todo Backend

## Categories :

- ### Categories Model:

  - Create an edit category function
  - Add it to exports

- ### Categories Controller :

  - Create the edit category function in the controller
  - Get token and parse it. Only admin can edit categories
  - Add it to exports

- ### Categories Routes :
  - Add the route to the file

---

## Comments :

- ### Comments Model :

  - Create add comment
  - Create edit comment
  - Create delete comment

- ### Comments Controller :

  - Get the token and parse it for all the functions above
  - Make the checks, the user needs to post under his own id, can only edit or delete his own comments. Also, check if we are posting on the correcting photo
  - Don't forget the security checks

- ### Comments Routes :
  - Add the route to the file

---

## Security :

Add token checks wherever they're needed (photos for example need to have token checks).

================
File: utils/db.js
================
const { Pool } = require('pg')
require('dotenv').config()

const pool = new Pool({
    connectionString: process.env.DATABASE_URL
})

/* Connection test */

// async function testConnection() {
//     try {
//         // Connect to the database
//         const test = await pool.query('SELECT * FROM users');
//         console.log(test.rows);
//     } catch (err) {
//         console.error('Error connecting to the database:', err.message);
//     }
// }

// testConnection();

module.exports = {
    pool
}
