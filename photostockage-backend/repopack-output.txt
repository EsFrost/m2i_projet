This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-04T12:50:11.374Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
controllers/CategoriesController.js
controllers/CommentsController.js
controllers/DownloadsController.js
controllers/LikesController.js
controllers/PhotoController.js
controllers/UserController.js
index.js
middleware/authMiddleware.js
models/CategoriesModel.js
models/CommentsModel.js
models/DownloadsModel.js
models/LikesModel.js
models/PhotoModel.js
models/UserModel.js
package.json
routes/categoriesRoute.js
routes/commentsRoute.js
routes/downloadsRoute.js
routes/likesRoute.js
routes/photoRoute.js
routes/userRoute.js
todo
todo.md
utils/db.js
utils/jwt.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Node modules
node_modules/

# Environment variables
.env

================
File: controllers/CategoriesController.js
================
const { v4: uuidv4 } = require("uuid");
const { createCategory } = require("../models/CategoriesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");

const categoryModel = require("../models/CategoriesModel");

async function showCategories(req, res) {
  try {
    const result = await categoryModel.getCategories();
    res.send(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showCategoryById(req, res) {
  const id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const result = await categoryModel.getCategoryById(id);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid UUID" });
  }
}

async function showCategoryByName(req, res) {
  const name = sanitizeHtml(req.params.name);
  if (validator.isString(name)) {
    try {
      const result = await categoryModel.getCategoryByName(name);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  }
}

async function createCategory(req, res) {
  let { name, description } = req.body;
  const id = uuidv4();
  let sanitizedName = sanitizeHtml(name);
  let sanitizedDescription = sanitizeHtml(description);

  if (validator.isUUID(id) && name && description) {
    try {
      await categoryModel.createCategory(
        id,
        sanitizedName,
        sanitizedDescription
      );
      res.status(201).json({ message: "Category created successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to create category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

/* Edit category, admin only */
async function editCategory(req, res) {
  let { cid, name, description } = req.body;

  const sanitizedName = sanitizeHtml(name);
  const sanitizedDescription = sanitizeHtml(description);

  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Authentication failed" });
  }

  // check if the user is admin here

  try {
    // Verify the token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // Check if user is admin
    if (!decoded.isAdmin) {
      return res.status(403).json({ message: "Admin access required" });
    }

    let { cid, name, description } = req.body;
    const sanitizedName = sanitizeHtml(name);
    const sanitizedDescription = sanitizeHtml(description);

    if (
      validator.isUUID(cid) &&
      name !== null &&
      name !== undefined &&
      description !== null &&
      description !== undefined
    ) {
      await categoryModel.editCategory(
        cid,
        sanitizedName,
        sanitizedDescription
      );
      res.status(200).json({ message: "Category edited successfully" });
    } else {
      res.status(400).json({ message: "Invalid input data" });
    }
  } catch (err) {
    if (err.name === "TokenExpiredError") {
      return res.status(401).json({ message: "Token expired" });
    } else if (err.name === "JsonWebTokenError") {
      return res.status(401).json({ message: "Invalid token" });
    }
    res
      .status(500)
      .json({ message: "Failed to edit category", error: err.message });
  }
}

module.exports = {
  showCategories,
  createCategory,
  showCategoryById,
  showCategoryByName,
};

================
File: controllers/CommentsController.js
================
const commentsModel = require("../models/CommentsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function showAllPhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getAllPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

module.exports = {
  showActivePhotoComments,
  showAllPhotoComments,
};

================
File: controllers/DownloadsController.js
================
const downloadsModel = require("../models/DownloadsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function checkDownloads(id_user, id_photo) {
  try {
    const result = await downloadsModel.getAllDownloads();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    console.log(err);
    throw err;
  }
}

async function addDownload(req, res) {
  let { id_photo } = req.body;
  const id_user = req.user.id; // Get user id from the authenticated token
  id_photo = sanitizeHtml(id_photo);
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkDownloads(id_user, id_photo);
      if (check === true) {
        res
          .status(200)
          .json({ warning: "You have already downloaded this photo!" });
      } else {
        await downloadsModel.addDownload(id, id_user, id_photo);
        res
          .status(201)
          .json({ message: "Download added to library successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUserDownloads(req, res) {
  let u_id = req.params.u_id;
  u_id = sanitizeHtml(u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these downloads" });
    }
    try {
      const result = await downloadsModel.getUserDownloads(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

module.exports = {
  showUserDownloads,
  addDownload,
};

================
File: controllers/LikesController.js
================
const likesModel = require("../models/LikesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.countPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function getUserLikes(req, res) {
  let u_id = sanitizeHtml(req.params.u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these likes" });
    }
    try {
      const result = await likesModel.getUserLikes(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

async function getPhotoLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.getPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function checkLikes(id_user, id_photo) {
  try {
    const result = await likesModel.getAllLikes();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    throw err;
  }
}

async function addLike(req, res) {
  let { id_photo } = req.body;
  const id_user = req.user.id; // Get user id from the authenticated token
  id_photo = sanitizeHtml(id_photo);
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        res.status(200).json({ warning: "You have already liked this photo!" });
      } else {
        await likesModel.likePhoto(id, id_user, id_photo);
        res.status(201).json({ message: "Like added successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deleteLike(req, res) {
  let { id_photo } = req.params;
  const id_user = req.user.id; // Get user id from the authenticated token
  id_photo = sanitizeHtml(id_photo);
  if (validator.isUUID(id_user) && validator.isUUID(id_photo)) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        await likesModel.unlikePhoto(id_user, id_photo);
        res.status(200).json({ message: "Photo unliked!" });
      } else {
        res.status(200).json({ warning: "You have not liked this photo!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showLikes,
  getUserLikes,
  getPhotoLikes,
  addLike,
  deleteLike,
};

================
File: controllers/PhotoController.js
================
const photoModel = require("../models/PhotoModel");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotos(req, res) {
  try {
    const result = await photoModel.getActivePhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhotos(req, res) {
  try {
    const result = await photoModel.getPhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getPhoto(id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotos(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getUserPhotos(id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotoById(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  let u_id = sanitizeHtml(req.params.u_id);

  if (validator.isUUID(p_id) && validator.isUUID(u_id)) {
    try {
      const result = await photoModel.getUserPhotoById(p_id, u_id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function newPhoto(req, res) {
  let { name, description, path, status } = req.body;
  let user_id = req.user.id; // Get user id from the authenticated token
  let id = uuidv4();

  if (
    status === undefined ||
    status === "" ||
    status === null ||
    path === undefined ||
    path === null ||
    path === ""
  ) {
    status = false;
  }

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);
  path = sanitizeHtml(path);

  if (
    validator.isUUID(user_id) &&
    validator.isUUID(id) &&
    (validator.isURL(path) ||
      path === "" ||
      path === null ||
      path === undefined) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      await photoModel.createPhoto(
        id,
        user_id,
        name,
        description,
        path,
        status
      );
      res.status(201).json({ message: `Photo ${name} created successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deletePhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to delete this photo" });
      }
      await photoModel.deletePhoto(id);
      res.status(200).json({ message: `Photo deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function editPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  let { name, description, status } = req.body;

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);

  if (
    validator.isUUID(id) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to edit this photo" });
      }
      await photoModel.editPhoto(name, description, status, id);
      res.status(200).json({ message: `Photo updated successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showActivePhotos,
  showPhotos,
  showPhoto,
  showUserPhotos,
  showUserPhotoById,
  newPhoto,
  deletePhoto,
  editPhoto,
};

================
File: controllers/UserController.js
================
const userModel = require("../models/UserModel");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const secret = process.env.JWT_SECRET;
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function loginUser(req, res) {
  let { email, password } = req.body;
  email = sanitizeHtml(email);
  password = sanitizeHtml(password);

  if (validator.isEmail(email) && validator.isAlphanumeric(password)) {
    try {
      const user = await userModel.getUserByEmail(email);
      if (user.rows.length === 0) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const isMatch = await bcrypt.compare(password, user.rows[0].password);
      if (!isMatch) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = jwt.sign(
        {
          id: user.rows[0].id,
          username: user.rows[0].username,
          email: user.rows[0].email,
          access_level: user.rows[0].access_level, // Add access_level to token payload
        },
        secret,
        { expiresIn: "30d" }
      );

      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
        sameSite: "strict", // Added security measure
      });

      res.status(200).json({
        message: "Login successful",
        token: token,
      });
    } catch (err) {
      res.status(500).json({ error: "Internal server error" });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUsers(req, res) {
  try {
    const result = await userModel.getUsers();
    res.send(result.rows);
  } catch (err) {
    res.send(err);
  }
}

async function showUser(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUser(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUsername(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUsername(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUserByEmail(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    try {
      const result = await userModel.getUserByEmail(email);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  }
}

async function registerUser(req, res) {
  let { username, password, email, user_icon } = req.body;
  const id = uuidv4();
  username = sanitizeHtml(username);
  password = sanitizeHtml(password);
  email = sanitizeHtml(email);
  user_icon = sanitizeHtml(user_icon);

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    validator.isEmail(email) &&
    validator.isAlphanumeric(password) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      const salt = bcrypt.genSaltSync(10);
      const hash = bcrypt.hashSync(password, salt);

      await userModel.newUser(id, username, email, hash, user_icon);

      const user = { id, email, username };
      const token = generateToken(user);

      res.status(201).json({
        message: `User ${email} created successfully!`,
        token,
        user,
      });
    } catch (err) {
      if (err.code === "23505") {
        res.status(400).json({ message: `Email or username already exists!` });
      } else if (err.code === "22P02") {
        res.status(400).json({ message: `Invalid data!` });
      } else {
        console.error(err);
        res
          .status(500)
          .json({ error: "Internal server error", details: err.message });
      }
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function delUser(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    if (email !== req.user.email) {
      return res
        .status(403)
        .json({ error: "Not authorized to delete this user" });
    }
    try {
      await userModel.deleteUser(email);
      res.clearCookie("token");
      res.status(200).json({ message: `User ${email} deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid email format" });
  }
}

// need to validate using jwt and compare hashed password / id / email / username
async function changePass(req, res) {
  let { email, currentPassword, newPassword } = req.body;

  email = sanitizeHtml(email);
  currentPassword = sanitizeHtml(currentPassword);
  newPassword = sanitizeHtml(newPassword);

  if (email !== req.user.email) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's password" });
  }

  if (
    !validator.isEmail(email) ||
    !validator.isAlphanumeric(currentPassword) ||
    !validator.isAlphanumeric(newPassword)
  ) {
    return res.status(400).json({ error: "Invalid data!" });
  }

  try {
    const user = await userModel.getUserByEmail(email);
    if (user.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const isMatch = await bcrypt.compare(
      currentPassword,
      user.rows[0].password
    );
    if (!isMatch) {
      return res.status(401).json({ error: "Current password is incorrect" });
    }

    const salt = bcrypt.genSaltSync(10);
    const hash = bcrypt.hashSync(newPassword, salt);

    await userModel.editPassword(hash, email);
    res.status(200).json({ message: "Password updated successfully!" });
  } catch (err) {
    console.error("Error in changePass:", err);
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

// validation needed here also
async function changeUser(req, res) {
  let { username, user_icon } = req.body;
  let id = req.params.id;

  username = sanitizeHtml(username);
  user_icon = sanitizeHtml(user_icon);

  if (id !== req.user.id) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's information" });
  }

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    (validator.isURL(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      await userModel.editUser(username, user_icon, id);
      res.status(200).json({ message: "User updated successfully!" });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showUsers,
  showUser,
  showUsername,
  registerUser,
  showUserByEmail,
  delUser,
  changePass,
  changeUser,
  loginUser,
};

================
File: index.js
================
const express = require("express");
const app = express();
const cors = require("cors");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const cookieParser = require("cookie-parser"); // Add this line
const userRoute = require("./routes/userRoute");
const photoRoute = require("./routes/photoRoute");
const categoriesRoute = require("./routes/categoriesRoute");
const likesRoute = require("./routes/likesRoute");
const downloadsRoute = require("./routes/downloadsRoute");
const commentsRoute = require("./routes/commentsRoute");

app.use(express.json());
app.use(helmet());
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true, // Allows cookies with CORS
  })
);
app.use(cookieParser()); // Uses the cookie parser

const limiter = rateLimit({
  windowsMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per `window` (here, per 15 minutes)
});

app.use(limiter);

app.use("/user", userRoute);
app.use("/photos", photoRoute);
app.use("/categories", categoriesRoute);
app.use("/likes", likesRoute);
app.use("/downloads", downloadsRoute);
app.use("/comments", commentsRoute);

app.listen(3000, () => {
  console.log("Server is running on port 3000");
});

================
File: middleware/authMiddleware.js
================
const jwt = require("jsonwebtoken");
require("dotenv").config();

const authMiddleware = (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ error: "Token expired" });
    }
    return res.status(401).json({ error: "Invalid token" });
  }
};

const isAdmin = (req, res, next) => {
  if (!req.user || !req.user.access_level) {
    return res.status(403).json({ error: "Admin access required" });
  }
  next();
};

module.exports = { authMiddleware, isAdmin };

================
File: models/CategoriesModel.js
================
const { pool } = require("../utils/db");

function getCategories() {
  return pool.query(`SELECT * FROM categories`);
}

/* Untested functionality */
function getCategoryById(id) {
  return pool.query(`SELECT * FROM categories WHERE id = $1`, [id]);
}

/* Untested functionality */
function getCategoryByName(name) {
  return pool.query(`SELECT * FROM categories WHERE name = $1`, [name]);
}

/* Untested functionality */
function createCategory(id, name, description) {
  return pool.query(
    `INSERT INTO categories (id, name, description) VALUES ($1, $2, $3)`,
    [id, name, description]
  );
}

/* Edit category, admin only */
function editCategory(id, name, description) {
  return pool.query(
    `UPDATE categories SET name = $1, description = $2 WHERE id = $3`,
    [id, name, description]
  );
}

module.exports = {
  getCategories,
  createCategory,
  getCategoryById,
  getCategoryByName,
  editCategory,
};

================
File: models/CommentsModel.js
================
const { pool } = require("../utils/db");

function getPhotoComments(p_id) {
  return pool.query(
    `SELECT * FROM comments WHERE id_photo = $1 AND status = true`,
    [p_id]
  );
}

function getAllPhotoComments(p_id) {
  return pool.query(`SELECT * FROM comments WHERE id_photo = $1`, [p_id]);
}

module.exports = {
  getPhotoComments,
  getAllPhotoComments,
};

================
File: models/DownloadsModel.js
================
const { pool } = require('../utils/db')

function getUserDownloads(u_id) {
    return pool.query(`
        SELECT * FROM downloads
        JOIN photos ON downloads.id_photo = photos.id
        WHERE id_user = $1`, [u_id])
}

function addDownload(id, u_id, p_id) {
    return pool.query(`INSERT INTO downloads (id, id_user, id_photo) VALUES ($1, $2, $3)`, [id, u_id, p_id])
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllDownloads() {
    return pool.query(`SELECT id_user, id_photo FROM downloads`)
}


module.exports = {
    getUserDownloads,
    addDownload,
    getAllDownloads
}

================
File: models/LikesModel.js
================
const { pool } = require('../utils/db')

/* Returns all the photos the user has liked */
/* Change star to specific fields due to memory leaks! */
function getUserLikes(u_id) {
    return pool.query(`
        SELECT * FROM likes l
        JOIN photos p ON l.id_photo = p.id
        WHERE l.id_user = $1`, [u_id])
}

/* Should return the username of people that liked the photo */
/* Change star to specific fields due to memory leaks! */
function getPhotoLikes(p_id) {
    return pool.query(`
        SELECT * FROM likes l
        JOIN users u ON l.id_user = u.id
        WHERE l.id_photo = $1`, [p_id])
}

/* Returns the number of likes on a specific photo */
function countPhotoLikes(p_id) {
    return pool.query(`SELECT COUNT(*) FROM likes l
    JOIN photos p ON l.id_photo = p.id
    WHERE l.id_photo = $1`, [p_id])
}

/* Unlike photo */
function unlikePhoto(u_id, p_id) {
    return pool.query(`DELETE FROM likes WHERE id_user = $1 AND id_photo = $2`, [u_id, p_id])
}

/* Like photo */
function likePhoto(id, u_id, p_id) {
    return pool.query(`INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3)`, [id, u_id, p_id])
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllLikes() {
    return pool.query(`SELECT id_user, id_photo FROM likes`)
}

module.exports = {
    getUserLikes,
    getPhotoLikes,
    countPhotoLikes,
    likePhoto,
    getAllLikes,
    unlikePhoto
}

================
File: models/PhotoModel.js
================
const { pool } = require('../utils/db')

function getActivePhotos() {
    return pool.query('SELECT * FROM photos WHERE status = true')
}

function getPhotos() {
    return pool.query('SELECT * FROM photos')
}

function getPhoto(id) {
    const req = `SELECT * FROM photos WHERE id = $1`
    return pool.query(req, [id])
}

function getUserPhotos(id) {
    const req = `SELECT * FROM photos WHERE user_id = $1`
    return pool.query(req, [id])
}

function getUserPhotoById(p_id, u_id) {
    const req = `SELECT * FROM photos WHERE id = $1 AND user_id = $2`
    return pool.query(req, [p_id, u_id])
}

function createPhoto(id, user_id, name, description, path, status) {
    const req = `INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)`
    return pool.query(req, [id, user_id, name, description, path, status])
}


function deletePhoto(id) {
    const req = `DELETE FROM photos WHERE id = $1`
    return pool.query(req, [id])
}

function editPhoto(name, description, status, id) {
    const req = `UPDATE photos SET name = $1, description = $2, status = $3 WHERE id = $4`
    return pool.query(req, [name, description, status, id])
}


module.exports = {
    getActivePhotos,
    getPhotos,
    getPhoto,
    getUserPhotos,
    getUserPhotoById,
    createPhoto,
    deletePhoto,
    editPhoto
}

================
File: models/UserModel.js
================
const { pool } = require('../utils/db')

function getUsers() {
    return pool.query(`SELECT * FROM users`)
}

function getUser(id) {
    const req = `SELECT * FROM users WHERE id = $1`
    return pool.query(req, [id])
}

function getUserByEmail(email) {
    const req = `SELECT * FROM users WHERE email = $1`
    return pool.query(req, [email])
}

function getUsername(id) {
    const req = `SELECT username FROM users WHERE id = $1`
    return pool.query(req, [id])
}


function newUser(id, username, email, password, user_icon) {
    const req = `INSERT INTO users (id, username, email, password, user_icon) VALUES ($1, $2, $3, $4, $5)`
    return pool.query(req, [id, username, email, password, user_icon])
}

function deleteUser(email) {
    const req = `DELETE FROM users WHERE email = $1`
    return pool.query(req, [email])
}

function editUser(username, user_icon, id) {
    const req = `UPDATE users SET username = $1, user_icon = $2 WHERE id = $3`
    return pool.query(req, [username, user_icon, id])
}

async function editPassword(password, email) {

    const req = `UPDATE users SET password = $1 WHERE email = $2`
    return pool.query(req, [password, email])
}

module.exports = { 
    getUsers,
    getUser,
    getUsername,
    newUser,
    getUserByEmail,
    deleteUser,
    editUser,
    editPassword
}

================
File: package.json
================
{
  "name": "photostockage-backend",
  "version": "0.0.1",
  "description": "Backend for a project for my training at m2i",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "backend",
    "node",
    "nodejs"
  ],
  "author": "Sigmund Frost",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "sanitize-html": "^2.13.0",
    "sequelize": "^6.37.3",
    "uuidv4": "^6.2.13",
    "validator": "^13.12.0"
  }
}

================
File: routes/categoriesRoute.js
================
const express = require("express");
const categoriesRouter = express.Router();
const categoriesController = require("../controllers/CategoriesController");
const verifyJwtToken = require("../middleware/authMiddleware");

/* method GET */
categoriesRouter.get("/", categoriesController.showCategories);
categoriesRouter.get("/:id", categoriesController.showCategoryById);
categoriesRouter.get("/:name", categoriesController.showCategoryByName);

/* method POST */
categoriesRouter.post("/", verifyJwtToken, categoriesController.createCategory);

module.exports = categoriesRouter;

================
File: routes/commentsRoute.js
================
const express = require('express')
const commentsRouter = express.Router()
const commentsController = require('../controllers/CommentsController')

/* method: GET */
commentsRouter.get('/photo/:p_id', commentsController.showActivePhotoComments)
commentsRouter.get('/c_photo/:p_id', commentsController.showAllPhotoComments)

/* method: POST */

/* method: DELETE */

/* method: PUT */

module.exports = commentsRouter

================
File: routes/downloadsRoute.js
================
const express = require("express");
const downloadsRouter = express.Router();
const downloadsController = require("../controllers/DownloadsController");
const verifyJwtToken = require("../middleware/authMiddleware");

/* method: GET */
downloadsRouter.get(
  "/user/:u_id",
  verifyJwtToken,
  downloadsController.showUserDownloads
);

/* method: POST */
downloadsRouter.post(
  "/download",
  verifyJwtToken,
  downloadsController.addDownload
);

module.exports = downloadsRouter;

================
File: routes/likesRoute.js
================
const express = require("express");
const likesRouter = express.Router();
const likesController = require("../controllers/LikesController");
const verifyJwtToken = require("../middleware/authMiddleware");

/* method: GET */
likesRouter.get("/likes/:p_id", likesController.showLikes);
likesRouter.get("/user/:u_id", verifyJwtToken, likesController.getUserLikes);
likesRouter.get("/photo/:p_id", likesController.getPhotoLikes);

/* method: POST */
likesRouter.post("/like", verifyJwtToken, likesController.addLike);

/* method: DELETE */
likesRouter.delete(
  "/like/:id_photo",
  verifyJwtToken,
  likesController.deleteLike
);

module.exports = likesRouter;

================
File: routes/photoRoute.js
================
const express = require("express");
const photoRouter = express.Router();
const photoController = require("../controllers/PhotoController");
const verifyJwtToken = require("../middleware/authMiddleware");

/* method: GET */
photoRouter.get("/photos/admin", photoController.showPhotos);
photoRouter.get("/photos", photoController.showActivePhotos);
photoRouter.get("/photo/:id", photoController.showPhoto);
photoRouter.get("/photos/user/:id", photoController.showUserPhotos);
photoRouter.get("/photo/user/:p_id/:u_id", photoController.showUserPhotoById);

/* method: POST */
photoRouter.post("/add_photo", verifyJwtToken, photoController.newPhoto);

/* method: DELETE */
photoRouter.delete("/delete/:id", verifyJwtToken, photoController.deletePhoto);

/* method: PUT */
photoRouter.put("/edit/:id", verifyJwtToken, photoController.editPhoto);

module.exports = photoRouter;

================
File: routes/userRoute.js
================
const express = require("express");
const userRouter = express.Router();
const userController = require("../controllers/UserController");
const authMiddleware = require("../middleware/authMiddleware");

/* method: GET */
userRouter.get("/users", userController.showUsers);
userRouter.get("/user/:id", userController.showUser);
userRouter.get("/username/:id", userController.showUsername);
userRouter.get("/email/:email", userController.showUserByEmail);

/* method: POST */
userRouter.post("/register", userController.registerUser);
userRouter.post("/login", userController.loginUser);

/* method: DELETE */
userRouter.delete("/delete/:email", authMiddleware, userController.delUser);

/* method: PUT */
userRouter.put("/changepass", authMiddleware, userController.changePass);
userRouter.put("/changeuser/:id", authMiddleware, userController.changeUser);

module.exports = userRouter;

================
File: todo
================
add message if return.rows is emtpy
add message for errors
implement tokens
implement bcrypt for users controller
add requests to postman

================
File: todo.md
================
# Todo Backend

## Categories :

- ### Categories Model:

  - Create an edit category function
  - Add it to exports

- ### Categories Controller :

  - Create the edit category function in the controller
  - Get token and parse it. Only admin can edit categories
  - Add it to exports

- ### Categories Routes :
  - Add the route to the file

---

## Comments :

- ### Comments Model :

  - Create add comment
  - Create edit comment
  - Create delete comment

- ### Comments Controller :

  - Get the token and parse it for all the functions above
  - Make the checks, the user needs to post under his own id, can only edit or delete his own comments. Also, check if we are posting on the correcting photo
  - Don't forget the security checks

- ### Comments Routes :
  - Add the route to the file

---

## Security :

Add token checks wherever they're needed (photos for example need to have token checks).

================
File: utils/db.js
================
const { Pool } = require('pg')
require('dotenv').config()

const pool = new Pool({
    connectionString: process.env.DATABASE_URL
})

/* Connection test */

// async function testConnection() {
//     try {
//         // Connect to the database
//         const test = await pool.query('SELECT * FROM users');
//         console.log(test.rows);
//     } catch (err) {
//         console.error('Error connecting to the database:', err.message);
//     }
// }

// testConnection();

module.exports = {
    pool
}

================
File: utils/jwt.js
================
const jwt = require("jsonwebtoken");
require("dotenv").config();

const JWT_SECRET = process.env.JWT_SECRET;

function generateToken(user) {
  return jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, {
    expiresIn: "1d",
  });
}

function verifyToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

module.exports = { generateToken, verifyToken };

// middleware/auth.js

const { verifyToken } = require("../utils/jwt");

function authMiddleware(req, res, next) {
  const token = req.header("Authorization")?.replace("Bearer ", "");

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: "Invalid token" });
  }
}

module.exports = authMiddleware;
