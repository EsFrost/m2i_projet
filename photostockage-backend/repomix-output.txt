This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T09:45:30.583Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
__tests_/integration/category.test.js
__tests_/integration/comments.test.js
__tests_/integration/downloads.test.js
__tests_/integration/likes.test.js
__tests_/integration/photo.test.js
__tests_/integration/user.test.js
__tests_/setup/testDb.js
.dockerignore
.gitignore
backup.sql
controllers/CategoriesController.js
controllers/CommentsController.js
controllers/DownloadsController.js
controllers/LikesController.js
controllers/PhotoController.js
controllers/Photos_CategoriesController.js
controllers/UserController.js
docker-compose.yml
dockerfile
documentation.md
index.js
middleware/authMiddleware.js
models/CategoriesModel.js
models/CommentsModel.js
models/DownloadsModel.js
models/LikesModel.js
models/PhotoModel.js
models/Photos_CategoriesModel.js
models/UserModel.js
package.json
routes/categoriesRoute.js
routes/commentsRoute.js
routes/downloadsRoute.js
routes/likesRoute.js
routes/photoRoute.js
routes/photos_categoriesRoute.js
routes/userRoute.js
Tests.md
todo.txt
utils/db.js

================================================================
Repository Files
================================================================

================
File: __tests_/integration/category.test.js
================
// __tests__/integration/category.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let adminToken;
let userToken;

beforeAll(async () => {
  // Create admin user
  const adminData = {
    username: "admin",
    email: "admin@test.com",
    password: "Admin123",
    access_level: true,
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password, access_level) VALUES ($1, $2, $3, $4, $5)",
    [
      uuidv4(),
      adminData.username,
      adminData.email,
      adminData.password,
      adminData.access_level,
    ]
  );

  // Create test category
  await pool.query(
    "INSERT INTO categories (id, name, description) VALUES ($1, $2, $3)",
    [uuidv4(), "Test Category", "Test Description"]
  );

  adminToken = jwt.sign(
    {
      username: adminData.username,
      email: adminData.email,
      access_level: true,
    },
    process.env.JWT_SECRET
  );

  // Create regular user
  const userData = {
    username: "user",
    email: "user@test.com",
    password: "User123",
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [uuidv4(), userData.username, userData.email, userData.password]
  );

  userToken = jwt.sign(
    { username: userData.username, email: userData.email },
    process.env.JWT_SECRET
  );
});

afterAll(async () => {
  await pool.query("TRUNCATE users, categories CASCADE");
  await pool.end();
});

describe("Category Management", () => {
  describe("GET /categories", () => {
    it("returns all categories", async () => {
      const response = await request(app).get("/categories");

      expect(response.status).toBe(200);
      expect(response.body[0].name).toBe("Test Category");
    });
  });

  describe("POST /categories", () => {
    it("allows admin to create category", async () => {
      const response = await request(app)
        .post("/categories")
        .set("Cookie", [`token=${adminToken}`])
        .send({
          name: "New Category",
          description: "New Description",
        });

      expect(response.status).toBe(201);
    });

    it("prevents non-admin from creating category", async () => {
      const response = await request(app)
        .post("/categories")
        .set("Cookie", [`token=${userToken}`])
        .send({
          name: "New Category",
          description: "New Description",
        });

      expect(response.status).toBe(403);
    });
  });
});

================
File: __tests_/integration/comments.test.js
================
// __tests__/integration/comments.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

describe("Comments Management", () => {
  let userId, photoId, authToken;
  const timestamp = Date.now();

  beforeAll(async () => {
    // Create test user with unique email
    userId = uuidv4();
    await pool.query(
      "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
      [
        userId,
        `testuser_${timestamp}`,
        `test_${timestamp}@test.com`,
        "hashedpassword",
      ]
    );

    // Create test photo
    photoId = uuidv4();
    await pool.query(
      "INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)",
      [
        photoId,
        userId,
        "Test Photo",
        "Test Description",
        "/test/path.jpg",
        true,
      ]
    );

    // Generate auth token
    authToken = jwt.sign(
      { id: userId, username: `testuser_${timestamp}` },
      process.env.JWT_SECRET
    );
  });

  afterAll(async () => {
    await pool.query("TRUNCATE users, photos, comments CASCADE");
    await pool.end();
  });

  describe("POST /comments/add/:photo_id", () => {
    it("adds comment successfully", async () => {
      const response = await request(app)
        .post(`/comments/add/${photoId}`)
        .set("Cookie", [`token=${authToken}`])
        .send({ content: "Test comment" });

      expect(response.status).toBe(201);
    });
  });

  describe("PUT /comments/edit/:comment_id", () => {
    it("allows user to edit own comment", async () => {
      // Create a comment first
      const commentId = uuidv4();
      await pool.query(
        "INSERT INTO comments (id, id_user, id_photo, content) VALUES ($1, $2, $3, $4)",
        [commentId, userId, photoId, "Original comment"]
      );

      const response = await request(app)
        .put(`/comments/edit/${commentId}`)
        .set("Cookie", [`token=${authToken}`])
        .send({ content: "Updated comment" });

      expect(response.status).toBe(200);
    });
  });

  // __tests__/integration/comments.test.js
  describe("GET /comments/photo/:p_id", () => {
    it("returns active photo comments", async () => {
      // Add a test comment first
      const commentId = uuidv4();
      await pool.query(
        "INSERT INTO comments (id, id_user, id_photo, content, status) VALUES ($1, $2, $3, $4, $5)",
        [commentId, userId, photoId, "Test comment", true]
      );

      const response = await request(app).get(`/comments/photo/${photoId}`);

      expect(response.status).toBe(201); // This matches the actual API response
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body[0].content).toBe("Test comment");
    });
  });
});

================
File: __tests_/integration/downloads.test.js
================
// __tests__/integration/downloads.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let authToken;
let testUser;
let testPhoto;

beforeAll(async () => {
  // Create test user with unique username
  const userId = uuidv4();
  const timestamp = Date.now();
  testUser = {
    id: userId,
    username: `testuser_${timestamp}`,
    email: `test_${timestamp}@test.com`,
  };

  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [userId, testUser.username, testUser.email, "hashedpassword"]
  );

  // Create test photo
  const photoId = uuidv4();
  testPhoto = {
    id: photoId,
    name: "Test Photo",
    path: "/test/path.jpg",
    description: "Test description",
  };

  await pool.query(
    "INSERT INTO photos (id, user_id, name, path, description, status) VALUES ($1, $2, $3, $4, $5, $6)",
    [
      photoId,
      userId,
      testPhoto.name,
      testPhoto.path,
      testPhoto.description,
      true,
    ]
  );

  authToken = jwt.sign(testUser, process.env.JWT_SECRET);
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos, downloads CASCADE");
  await pool.end();
});

describe("Downloads Management", () => {
  describe("POST /downloads/download/:id_photo", () => {
    it("adds download successfully", async () => {
      const response = await request(app)
        .post(`/downloads/download/${testPhoto.id}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(201);
    });
  });

  describe("GET /downloads/user/:u_id", () => {
    it("returns user downloads", async () => {
      const response = await request(app)
        .get(`/downloads/user/${testUser.id}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
    });
  });
});

================
File: __tests_/integration/likes.test.js
================
// __tests__/integration/likes.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

let authToken;
let testPhotoId;

beforeAll(async () => {
  // Create test user
  const userId = uuidv4();
  await pool.query(
    "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
    [userId, "testuser", "test@test.com", "password123"]
  );

  // Create test photo
  testPhotoId = uuidv4();
  await pool.query(
    "INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6)",
    [testPhotoId, userId, "Test Photo", "Description", "path/to/photo", true]
  );

  // Create test like
  const likeId = uuidv4();
  await pool.query(
    "INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3)",
    [likeId, userId, testPhotoId]
  );

  authToken = jwt.sign(
    { id: userId, username: "testuser" },
    process.env.JWT_SECRET
  );
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos, likes CASCADE");
  await pool.end();
});

describe("Like Management", () => {
  describe("GET /likes/photo/:p_id", () => {
    it("returns photo likes count", async () => {
      const response = await request(app).get(`/likes/likes/${testPhotoId}`);

      expect(response.status).toBe(200);
      expect(response.body[0]).toHaveProperty("count");
      expect(parseInt(response.body[0].count)).toBe(1);
    });
  });

  describe("POST /likes/like/:id_photo", () => {
    it("prevents duplicate likes", async () => {
      const response = await request(app)
        .post(`/likes/like/${testPhotoId}`)
        .set("Cookie", [`token=${authToken}`]);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty("warning");
    });
  });
});

================
File: __tests_/integration/photo.test.js
================
// __tests__/integration/photo.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");

let authToken;
let testUser;

beforeAll(async () => {
  // Create test user
  const userData = {
    username: "testuser",
    email: "test@example.com",
    password: "Test123",
  };

  const registerResponse = await request(app)
    .post("/user/register")
    .send(userData);

  authToken = registerResponse.body.token;
  testUser = registerResponse.body.user;
});

afterAll(async () => {
  await pool.query("TRUNCATE users, photos CASCADE");
  await pool.end();
});

describe("Photo Management", () => {
  describe("Photo Creation", () => {
    const testPhoto = {
      name: "Test Photo",
      description: "Test Description",
      path: "https://example.com/test.jpg",
      status: true,
    };

    it("should create a new photo successfully", async () => {
      const response = await request(app)
        .post("/photos/add_photo")
        .set("Cookie", [`token=${authToken}`])
        .send(testPhoto);

      expect(response.status).toBe(201);
    });

    it("should reject photo creation without auth", async () => {
      const response = await request(app)
        .post("/photos/add_photo")
        .send(testPhoto);

      expect(response.status).toBe(401);
    });
  });

  describe("Photo Retrieval", () => {
    it("should get active photos", async () => {
      const response = await request(app).get("/photos/photos");

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
    });
  });
});

================
File: __tests_/integration/user.test.js
================
// __tests__/integration/user.test.js
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
require("dotenv").config();

describe("User Management", () => {
  let userId;
  let authToken;

  beforeAll(async () => {
    await pool.query("TRUNCATE users CASCADE");

    // Create test user directly in database
    userId = "550e8400-e29b-41d4-a716-446655440000";
    await pool.query(
      "INSERT INTO users (id, username, email, password) VALUES ($1, $2, $3, $4)",
      [userId, "testuser", "test@test.com", "hashedpassword"]
    );

    // Generate auth token
    authToken = jwt.sign(
      { id: userId, username: "testuser", email: "test@test.com" },
      process.env.JWT_SECRET
    );
  });

  afterAll(async () => {
    await pool.end();
  });

  describe("Profile Management", () => {
    it("updates profile successfully", async () => {
      const updatedProfile = {
        username: "updateduser",
        user_icon: "https://example.com/newicon.jpg",
      };

      const response = await request(app)
        .put(`/user/changeuser/${userId}`)
        .set("Cookie", [`token=${authToken}`])
        .send(updatedProfile);

      expect(response.status).toBe(200);
    });
  });
});

================
File: __tests_/setup/testDb.js
================
// __tests__/setup/testDb.js
const { pool } = require("../../utils/db");

async function cleanDatabase() {
  await pool.query(
    "TRUNCATE users, photos, comments, likes, downloads, categories CASCADE"
  );
}

async function seedTestData() {
  // Create test admin user
  const adminUser = await pool.query(
    `
    INSERT INTO users (id, username, email, password, access_level)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING *`,
    [
      "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "admin",
      "admin@test.com",
      "$2a$10$fakehashedpassword",
      true,
    ]
  );

  // Create test regular user
  const regularUser = await pool.query(
    `
    INSERT INTO users (id, username, email, password)
    VALUES ($1, $2, $3, $4)
    RETURNING *`,
    [
      "b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "user",
      "user@test.com",
      "$2a$10$fakehashedpassword",
    ]
  );

  // Create test category
  const category = await pool.query(
    `
    INSERT INTO categories (id, name, description)
    VALUES ($1, $2, $3)
    RETURNING *`,
    [
      "c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      "Test Category",
      "Test Description",
    ]
  );

  // Create test photo
  const photo = await pool.query(
    `
    INSERT INTO photos (id, user_id, name, description, path, status)
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING *`,
    [
      "d0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
      regularUser.rows[0].id,
      "Test Photo",
      "Test Photo Description",
      "https://example.com/test.jpg",
      true,
    ]
  );

  return {
    adminUser: adminUser.rows[0],
    regularUser: regularUser.rows[0],
    category: category.rows[0],
    photo: photo.rows[0],
  };
}

module.exports = {
  cleanDatabase,
  seedTestData,
};

================
File: .dockerignore
================
node_modules
npm-debug.log
.env

================
File: .gitignore
================
# Node modules
node_modules/

# Environment variables
.env
.env.docker

================
File: backup.sql
================
--
-- PostgreSQL database dump
--

-- Dumped from database version 16.4
-- Dumped by pg_dump version 17.0

-- Started on 2025-01-28 18:17:22

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 6 (class 2615 OID 19810)
-- Name: Database Schema; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA "Database Schema";


ALTER SCHEMA "Database Schema" OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- TOC entry 221 (class 1259 OID 18811)
-- Name: categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.categories (
    id text NOT NULL,
    name character varying(100) NOT NULL,
    description text NOT NULL
);


ALTER TABLE public.categories OWNER TO postgres;

--
-- TOC entry 220 (class 1259 OID 18793)
-- Name: comments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.comments (
    id text NOT NULL,
    content text NOT NULL,
    id_photo text,
    id_user text,
    status boolean DEFAULT false
);


ALTER TABLE public.comments OWNER TO postgres;

--
-- TOC entry 219 (class 1259 OID 18776)
-- Name: downloads; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.downloads (
    id text NOT NULL,
    id_photo text,
    id_user text
);


ALTER TABLE public.downloads OWNER TO postgres;

--
-- TOC entry 218 (class 1259 OID 18759)
-- Name: likes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.likes (
    id text NOT NULL,
    id_photo text,
    id_user text
);


ALTER TABLE public.likes OWNER TO postgres;

--
-- TOC entry 217 (class 1259 OID 18746)
-- Name: photos; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.photos (
    id text NOT NULL,
    user_id text NOT NULL,
    name character varying(50) NOT NULL,
    description text,
    path text NOT NULL,
    status boolean DEFAULT false
);


ALTER TABLE public.photos OWNER TO postgres;

--
-- TOC entry 222 (class 1259 OID 18818)
-- Name: photos_categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.photos_categories (
    id text NOT NULL,
    id_photo text,
    id_category text
);


ALTER TABLE public.photos_categories OWNER TO postgres;

--
-- TOC entry 216 (class 1259 OID 18734)
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id text NOT NULL,
    username character varying(25) NOT NULL,
    email character varying(30) NOT NULL,
    password text NOT NULL,
    access_level boolean DEFAULT false,
    user_icon text
);


ALTER TABLE public.users OWNER TO postgres;

--
-- TOC entry 4836 (class 0 OID 18811)
-- Dependencies: 221
-- Data for Name: categories; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.categories (id, name, description) FROM stdin;
aa0e8400-e29b-41d4-a716-446655440000	Nature	Photos of nature and landscapes
aa0e8400-e29b-41d4-a716-446655440001	Animals	Wildlife and pet photography
aa0e8400-e29b-41d4-a716-446655440002	Urban	City life and street photography
aa0e8400-e29b-41d4-a716-446655440003	People	Portraits and candid people photography
aa0e8400-e29b-41d4-a716-446655440004	Sports	Athletic events and sports activities
aa0e8400-e29b-41d4-a716-446655440005	Travel	Travel destinations and experiences
aa0e8400-e29b-41d4-a716-446655440006	Food	Culinary and food photography
aa0e8400-e29b-41d4-a716-446655440007	Architecture	Buildings and architectural details
aa0e8400-e29b-41d4-a716-446655440008	Art	Artistic and abstract photography
aa0e8400-e29b-41d4-a716-446655440009	Fashion	Fashion and style photography
\.


--
-- TOC entry 4835 (class 0 OID 18793)
-- Dependencies: 220
-- Data for Name: comments; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.comments (id, content, id_photo, id_user, status) FROM stdin;
990e8400-e29b-41d4-a716-446655440000	Great photo!	660e8400-e29b-41d4-a716-446655440000	550e8400-e29b-41d4-a716-446655440001	t
990e8400-e29b-41d4-a716-446655440001	Amazing shot!	660e8400-e29b-41d4-a716-446655440001	550e8400-e29b-41d4-a716-446655440002	f
990e8400-e29b-41d4-a716-446655440002	Nice angle.	660e8400-e29b-41d4-a716-446655440002	550e8400-e29b-41d4-a716-446655440003	t
990e8400-e29b-41d4-a716-446655440003	Beautiful colors!	660e8400-e29b-41d4-a716-446655440003	550e8400-e29b-41d4-a716-446655440004	f
990e8400-e29b-41d4-a716-446655440004	Stunning!	660e8400-e29b-41d4-a716-446655440004	550e8400-e29b-41d4-a716-446655440005	t
990e8400-e29b-41d4-a716-446655440005	I love it!	660e8400-e29b-41d4-a716-446655440005	550e8400-e29b-41d4-a716-446655440006	f
990e8400-e29b-41d4-a716-446655440006	Great capture!	660e8400-e29b-41d4-a716-446655440006	550e8400-e29b-41d4-a716-446655440007	t
990e8400-e29b-41d4-a716-446655440007	So cool!	660e8400-e29b-41d4-a716-446655440007	550e8400-e29b-41d4-a716-446655440008	f
990e8400-e29b-41d4-a716-446655440008	Fantastic!	660e8400-e29b-41d4-a716-446655440008	550e8400-e29b-41d4-a716-446655440009	t
990e8400-e29b-41d4-a716-446655440009	Love this!	660e8400-e29b-41d4-a716-446655440009	550e8400-e29b-41d4-a716-446655440000	f
fe358e89-532a-4139-8a94-efdcd33c9e92	This is a comment.	660e8400-e29b-41d4-a716-446655440004	b3902bd6-883e-4d43-a496-d63b943b70c1	t
189c7324-821e-4031-852c-6819d668a7f5	Does this work?	660e8400-e29b-41d4-a716-446655440004	0cb7613c-5adf-4b41-96d9-98248f6d5a8f	t
\.


--
-- TOC entry 4834 (class 0 OID 18776)
-- Dependencies: 219
-- Data for Name: downloads; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.downloads (id, id_photo, id_user) FROM stdin;
880e8400-e29b-41d4-a716-446655440000	660e8400-e29b-41d4-a716-446655440000	550e8400-e29b-41d4-a716-446655440002
880e8400-e29b-41d4-a716-446655440001	660e8400-e29b-41d4-a716-446655440001	550e8400-e29b-41d4-a716-446655440003
880e8400-e29b-41d4-a716-446655440002	660e8400-e29b-41d4-a716-446655440002	550e8400-e29b-41d4-a716-446655440004
880e8400-e29b-41d4-a716-446655440003	660e8400-e29b-41d4-a716-446655440003	550e8400-e29b-41d4-a716-446655440005
880e8400-e29b-41d4-a716-446655440004	660e8400-e29b-41d4-a716-446655440004	550e8400-e29b-41d4-a716-446655440006
880e8400-e29b-41d4-a716-446655440005	660e8400-e29b-41d4-a716-446655440005	550e8400-e29b-41d4-a716-446655440007
880e8400-e29b-41d4-a716-446655440006	660e8400-e29b-41d4-a716-446655440006	550e8400-e29b-41d4-a716-446655440008
880e8400-e29b-41d4-a716-446655440007	660e8400-e29b-41d4-a716-446655440007	550e8400-e29b-41d4-a716-446655440009
880e8400-e29b-41d4-a716-446655440008	660e8400-e29b-41d4-a716-446655440008	550e8400-e29b-41d4-a716-446655440000
880e8400-e29b-41d4-a716-446655440009	660e8400-e29b-41d4-a716-446655440009	550e8400-e29b-41d4-a716-446655440001
90f9dc90-a6ae-438a-b489-43186f38c150	660e8400-e29b-41d4-a716-446655440004	b3902bd6-883e-4d43-a496-d63b943b70c1
\.


--
-- TOC entry 4833 (class 0 OID 18759)
-- Dependencies: 218
-- Data for Name: likes; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.likes (id, id_photo, id_user) FROM stdin;
770e8400-e29b-41d4-a716-446655440000	660e8400-e29b-41d4-a716-446655440000	550e8400-e29b-41d4-a716-446655440001
770e8400-e29b-41d4-a716-446655440001	660e8400-e29b-41d4-a716-446655440001	550e8400-e29b-41d4-a716-446655440002
770e8400-e29b-41d4-a716-446655440002	660e8400-e29b-41d4-a716-446655440002	550e8400-e29b-41d4-a716-446655440003
770e8400-e29b-41d4-a716-446655440003	660e8400-e29b-41d4-a716-446655440003	550e8400-e29b-41d4-a716-446655440004
770e8400-e29b-41d4-a716-446655440004	660e8400-e29b-41d4-a716-446655440004	550e8400-e29b-41d4-a716-446655440005
770e8400-e29b-41d4-a716-446655440005	660e8400-e29b-41d4-a716-446655440005	550e8400-e29b-41d4-a716-446655440006
770e8400-e29b-41d4-a716-446655440006	660e8400-e29b-41d4-a716-446655440006	550e8400-e29b-41d4-a716-446655440007
770e8400-e29b-41d4-a716-446655440007	660e8400-e29b-41d4-a716-446655440007	550e8400-e29b-41d4-a716-446655440008
770e8400-e29b-41d4-a716-446655440008	660e8400-e29b-41d4-a716-446655440008	550e8400-e29b-41d4-a716-446655440009
770e8400-e29b-41d4-a716-446655440009	660e8400-e29b-41d4-a716-446655440009	550e8400-e29b-41d4-a716-446655440000
29ea585a-41fd-4445-8a94-6c356c77e71b	660e8400-e29b-41d4-a716-446655440004	b3902bd6-883e-4d43-a496-d63b943b70c1
\.


--
-- TOC entry 4832 (class 0 OID 18746)
-- Dependencies: 217
-- Data for Name: photos; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.photos (id, user_id, name, description, path, status) FROM stdin;
660e8400-e29b-41d4-a716-446655440004	550e8400-e29b-41d4-a716-446655440004	Photo5	Description5	/images/demo/image-5.jpg	t
660e8400-e29b-41d4-a716-446655440000	550e8400-e29b-41d4-a716-446655440000	Photo1	Description1	/images/demo/image-1.jpg	t
660e8400-e29b-41d4-a716-446655440002	550e8400-e29b-41d4-a716-446655440002	Photo3	Description3	/images/demo/image-3.jpg	t
660e8400-e29b-41d4-a716-446655440006	550e8400-e29b-41d4-a716-446655440006	Photo7	Description7	/images/demo/image-7.jpg	t
660e8400-e29b-41d4-a716-446655440008	550e8400-e29b-41d4-a716-446655440008	Photo9	Description9	/images/demo/image-9.jpg	t
660e8400-e29b-41d4-a716-446655440009	550e8400-e29b-41d4-a716-446655440009	Photo10	Description10	/images/demo/image-10.jpg	f
660e8400-e29b-41d4-a716-446655440001	550e8400-e29b-41d4-a716-446655440001	Photo2	Description2	/images/demo/image-2.jpg	t
660e8400-e29b-41d4-a716-446655440003	550e8400-e29b-41d4-a716-446655440003	Photo4	Description4	/images/demo/image-4.jpg	t
660e8400-e29b-41d4-a716-446655440005	550e8400-e29b-41d4-a716-446655440005	Photo6	Description6	/images/demo/image-6.jpg	t
660e8400-e29b-41d4-a716-446655440007	550e8400-e29b-41d4-a716-446655440007	Photo8	Description8	/images/demo/image-8.jpg	f
051a100f-d2c8-42c7-80c8-7a2825a4948a	b3902bd6-883e-4d43-a496-d63b943b70c1	asfasdf		/images/users/2ec7eb2a-1c6e-4d02-a812-f6ba7fc63c9a.jpg	t
007dc6fb-9e1f-49ea-90b7-df4587c7b70f	b3902bd6-883e-4d43-a496-d63b943b70c1	hdfdfgh		/images/users/e402baef-e669-4de7-9bc0-6540c7031a9a.png	t
d1cb9515-cb5f-4c72-991b-236ed0752999	b3902bd6-883e-4d43-a496-d63b943b70c1	ygzdxfg	afsdfasd	/images/users/e3c71c53-50e0-4096-973a-c746d518444b.jpg	t
898907a9-9bb8-4f3c-8bf8-afc9fb11b851	b3902bd6-883e-4d43-a496-d63b943b70c1	My photo	My description	/images/users/96c3eceb-b3d1-4fd8-b7e9-eb3fedffc3a7.jpg	f
e053cde0-6db7-4d42-a1c3-d221c22c37fb	b3902bd6-883e-4d43-a496-d63b943b70c1	gsdfg		/images/users/7306b0ac-120e-4688-add2-435d16ed644e.png	f
27cc27de-1d69-4fbe-9d57-f460b744b7c4	b3902bd6-883e-4d43-a496-d63b943b70c1	Another Photo	Another description	/images/users/bf863973-0857-4656-867f-c5f2a530eecd.jpg	t
\.


--
-- TOC entry 4837 (class 0 OID 18818)
-- Dependencies: 222
-- Data for Name: photos_categories; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.photos_categories (id, id_photo, id_category) FROM stdin;
bb0e8400-e29b-41d4-a716-446655440000	660e8400-e29b-41d4-a716-446655440000	aa0e8400-e29b-41d4-a716-446655440000
bb0e8400-e29b-41d4-a716-446655440001	660e8400-e29b-41d4-a716-446655440001	aa0e8400-e29b-41d4-a716-446655440001
bb0e8400-e29b-41d4-a716-446655440002	660e8400-e29b-41d4-a716-446655440002	aa0e8400-e29b-41d4-a716-446655440002
bb0e8400-e29b-41d4-a716-446655440003	660e8400-e29b-41d4-a716-446655440003	aa0e8400-e29b-41d4-a716-446655440003
bb0e8400-e29b-41d4-a716-446655440004	660e8400-e29b-41d4-a716-446655440004	aa0e8400-e29b-41d4-a716-446655440004
bb0e8400-e29b-41d4-a716-446655440005	660e8400-e29b-41d4-a716-446655440005	aa0e8400-e29b-41d4-a716-446655440005
bb0e8400-e29b-41d4-a716-446655440006	660e8400-e29b-41d4-a716-446655440006	aa0e8400-e29b-41d4-a716-446655440006
bb0e8400-e29b-41d4-a716-446655440007	660e8400-e29b-41d4-a716-446655440007	aa0e8400-e29b-41d4-a716-446655440007
bb0e8400-e29b-41d4-a716-446655440008	660e8400-e29b-41d4-a716-446655440008	aa0e8400-e29b-41d4-a716-446655440008
bb0e8400-e29b-41d4-a716-446655440009	660e8400-e29b-41d4-a716-446655440009	aa0e8400-e29b-41d4-a716-446655440009
b3991c81-c3d0-4796-9ec0-378814096f63	27cc27de-1d69-4fbe-9d57-f460b744b7c4	aa0e8400-e29b-41d4-a716-446655440009
\.


--
-- TOC entry 4831 (class 0 OID 18734)
-- Dependencies: 216
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, username, email, password, access_level, user_icon) FROM stdin;
550e8400-e29b-41d4-a716-446655440001	user2	user2@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
550e8400-e29b-41d4-a716-446655440002	user3	user3@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
550e8400-e29b-41d4-a716-446655440003	user4	user4@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	t	
550e8400-e29b-41d4-a716-446655440004	user5	user5@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
550e8400-e29b-41d4-a716-446655440005	user6	user6@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
550e8400-e29b-41d4-a716-446655440006	user7	user7@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	t	
550e8400-e29b-41d4-a716-446655440007	user8	user8@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
550e8400-e29b-41d4-a716-446655440008	user9	user9@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	t	
550e8400-e29b-41d4-a716-446655440009	user10	user10@example.com	$2a$10$6gvxYYVxZJ2uF4cdhkFZ.eZ896YU9Z0z6LrJ8TdI7YqJ0TwzR/HUi	f	
0cb7613c-5adf-4b41-96d9-98248f6d5a8f	user	user@user.com	$2a$10$pN9yuOD.cFN88.JdpdtODubIz/sjOzp1.Wdjo1UATeVblb7o8qMvy	f	/images/users/04a4826c-0754-4264-970b-eeca75da6582.jpg
b3902bd6-883e-4d43-a496-d63b943b70c1	testuser	test@test.com	$2a$10$h8gDM3NUNmJFNuACfXy52un6QMOI4kUq3wGg6ZCWiRkC2z9MDYFGq	f	
550e8400-e29b-41d4-a716-446655440000	Administrator	user1@example.com	$2a$10$mUVY.k3x9n3vxFE2oErlQe4UNCGkQusgGzVcDC7.bpLmevuXbar8q	t	/images/users/e7f3b1e9-7959-4d65-a692-e7ebc0d6de61.png
\.


--
-- TOC entry 4676 (class 2606 OID 18817)
-- Name: categories categories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (id);


--
-- TOC entry 4674 (class 2606 OID 18800)
-- Name: comments comments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_pkey PRIMARY KEY (id);


--
-- TOC entry 4672 (class 2606 OID 18782)
-- Name: downloads downloads_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.downloads
    ADD CONSTRAINT downloads_pkey PRIMARY KEY (id);


--
-- TOC entry 4670 (class 2606 OID 18765)
-- Name: likes likes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT likes_pkey PRIMARY KEY (id);


--
-- TOC entry 4678 (class 2606 OID 18824)
-- Name: photos_categories photos_categories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.photos_categories
    ADD CONSTRAINT photos_categories_pkey PRIMARY KEY (id);


--
-- TOC entry 4668 (class 2606 OID 18753)
-- Name: photos photos_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT photos_pkey PRIMARY KEY (id);


--
-- TOC entry 4662 (class 2606 OID 18745)
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- TOC entry 4664 (class 2606 OID 18741)
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- TOC entry 4666 (class 2606 OID 18743)
-- Name: users users_username_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_username_key UNIQUE (username);


--
-- TOC entry 4684 (class 2606 OID 18801)
-- Name: comments comments_id_photo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_id_photo_fkey FOREIGN KEY (id_photo) REFERENCES public.photos(id);


--
-- TOC entry 4685 (class 2606 OID 18806)
-- Name: comments comments_id_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.comments
    ADD CONSTRAINT comments_id_user_fkey FOREIGN KEY (id_user) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- TOC entry 4682 (class 2606 OID 18783)
-- Name: downloads downloads_id_photo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.downloads
    ADD CONSTRAINT downloads_id_photo_fkey FOREIGN KEY (id_photo) REFERENCES public.photos(id);


--
-- TOC entry 4683 (class 2606 OID 18788)
-- Name: downloads downloads_id_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.downloads
    ADD CONSTRAINT downloads_id_user_fkey FOREIGN KEY (id_user) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- TOC entry 4680 (class 2606 OID 18766)
-- Name: likes likes_id_photo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT likes_id_photo_fkey FOREIGN KEY (id_photo) REFERENCES public.photos(id);


--
-- TOC entry 4681 (class 2606 OID 18771)
-- Name: likes likes_id_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.likes
    ADD CONSTRAINT likes_id_user_fkey FOREIGN KEY (id_user) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- TOC entry 4686 (class 2606 OID 18830)
-- Name: photos_categories photos_categories_id_category_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.photos_categories
    ADD CONSTRAINT photos_categories_id_category_fkey FOREIGN KEY (id_category) REFERENCES public.categories(id) ON DELETE CASCADE;


--
-- TOC entry 4687 (class 2606 OID 18825)
-- Name: photos_categories photos_categories_id_photo_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.photos_categories
    ADD CONSTRAINT photos_categories_id_photo_fkey FOREIGN KEY (id_photo) REFERENCES public.photos(id);


--
-- TOC entry 4679 (class 2606 OID 18754)
-- Name: photos photos_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.photos
    ADD CONSTRAINT photos_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


-- Completed on 2025-01-28 18:17:22

--
-- PostgreSQL database dump complete
--

================
File: controllers/CategoriesController.js
================
const { v4: uuidv4 } = require("uuid");
const categoryModel = require("../models/CategoriesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");

async function showCategories(req, res) {
  try {
    const result = await categoryModel.getCategories();
    res.send(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showCategoryById(req, res) {
  const id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const result = await categoryModel.getCategoryById(id);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid UUID" });
  }
}

async function showCategoryByName(req, res) {
  const name = sanitizeHtml(req.params.name);
  if (name && typeof name === "string") {
    try {
      const result = await categoryModel.getCategoryByName(name);
      res.status(200).json({ result: result.rows });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid name format" });
  }
}

async function createCategory(req, res) {
  // Check if user has admin access (belt and suspenders, since middleware also checks)
  if (!req.user || !req.user.access_level) {
    return res.status(403).json({ error: "Admin access required" });
  }

  let { name, description } = req.body;
  const id = uuidv4();
  let sanitizedName = sanitizeHtml(name);
  let sanitizedDescription = sanitizeHtml(description);

  if (validator.isUUID(id) && name && description) {
    try {
      await categoryModel.createCategory(
        id,
        sanitizedName,
        sanitizedDescription
      );
      res.status(201).json({ message: "Category created successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to create category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

/* Edit category, admin only */
async function editCategory(req, res) {
  const id = sanitizeHtml(req.params.id);
  let { name, description } = req.body;

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);

  if (
    validator.isUUID(id) &&
    name &&
    name.trim() !== "" &&
    description &&
    description.trim() !== ""
  ) {
    try {
      await categoryModel.editCategory(id, name, description);
      res.status(200).json({ message: "Category edited successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to edit category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

async function deleteCategory(req, res) {
  const id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      await categoryModel.deleteCategory(id);
      res.status(200).json({ message: "Category deleted successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to delete category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid category ID" });
  }
}

module.exports = {
  showCategories,
  createCategory,
  showCategoryById,
  showCategoryByName,
  editCategory,
  deleteCategory,
};

================
File: controllers/CommentsController.js
================
const commentsModel = require("../models/CommentsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function showAllPhotoComments(req, res) {
  let { p_id } = req.params;
  p_id = sanitizeHtml(p_id);

  if (validator.isUUID(p_id)) {
    commentsModel
      .getAllPhotoComments(p_id)
      .then((result) => {
        res.status(201).json(result.rows);
      })
      .catch((err) => {
        res.status(500).json(err);
      });
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

// If html tags are to be added
// const sanitizeOptions = {
//   allowedTags: ["b", "i", "em", "strong", "u", "s", "h1", "h2", "h3", "p"],
//   allowedAttributes: {}, // No attributes allowed
// };

async function addComment(req, res) {
  const photo_id = sanitizeHtml(req.params.photo_id);
  const content = sanitizeHtml(req.body.content);
  const user_id = req.user.id;
  const id = uuidv4();

  if (!validator.isUUID(photo_id) || !content || content.trim() === "") {
    return res.status(400).json({ error: "Invalid input data" });
  }

  try {
    const photoStatus = await commentsModel.getPhotoStatus(photo_id);

    if (photoStatus.rows.length === 0) {
      return res.status(404).json({ error: "Photo not found" });
    }

    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot comment on inactive photos" });
    }

    const result = await commentsModel.addComment(
      id,
      user_id,
      photo_id,
      content
    );
    res.status(201).json({
      message: "Comment added successfully",
      comment: result.rows[0],
    });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to add comment", details: err.message });
  }
}

async function editComment(req, res) {
  const comment_id = sanitizeHtml(req.params.comment_id);
  const { content } = req.body;
  const user_id = req.user.id;

  if (!validator.isUUID(comment_id) || !content || content.trim() === "") {
    return res.status(400).json({ error: "Invalid input data" });
  }

  try {
    const commentResult = await commentsModel.getCommentDetails(comment_id);

    if (commentResult.rows.length === 0) {
      return res.status(404).json({ error: "Comment not found" });
    }

    const comment = commentResult.rows[0];

    if (comment.id_user !== user_id) {
      return res
        .status(403)
        .json({ error: "Not authorized to edit this comment" });
    }

    const photoStatus = await commentsModel.getPhotoStatus(comment.id_photo);
    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot edit comment on inactive photo" });
    }

    const result = await commentsModel.edtiComment(
      comment_id,
      user_id,
      content
    );
    res.status(200).json({
      message: "Comment updated successfully",
      comment: result.rows[0],
    });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to update comment", details: err.message });
  }
}

// Only showing the updated deleteComment function since it's the only one that needs admin logic
async function deleteComment(req, res) {
  let comment_id = sanitizeHtml(req.params.id);
  const user_id = req.user.id;
  const isAdmin = req.user.access_level; // From your JWT token

  if (!validator.isUUID(comment_id)) {
    return res.status(400).json({ error: "Invalid comment ID" });
  }

  try {
    // Check if comment exists and get its details
    const commentResult = await commentsModel.getCommentDetails(comment_id);

    if (commentResult.rows.length === 0) {
      return res.status(404).json({ error: "Comment not found" });
    }

    const comment = commentResult.rows[0];

    // Allow deletion if user is admin or comment owner
    if (!isAdmin && comment.id_user !== user_id) {
      return res
        .status(403)
        .json({ error: "Not authorized to delete this comment" });
    }

    // Check if photo is still active
    const photoStatus = await commentsModel.getPhotoStatus(comment.id_photo);
    if (!photoStatus.rows[0].status) {
      return res
        .status(403)
        .json({ error: "Cannot delete comment on inactive photo" });
    }

    await commentsModel.deleteComment(
      comment_id,
      isAdmin ? comment.id_user : user_id
    );
    res.status(200).json({ message: "Comment deleted successfully" });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to delete comment", details: err.message });
  }
}

async function showUserComments(req, res) {
  const user_id = req.params.user_id;

  if (!validator.isUUID(user_id)) {
    return res.status(400).json({ error: "Invalid user ID format" });
  }

  // Check if user is requesting their own comments
  if (user_id !== req.user.id) {
    return res
      .status(403)
      .json({ error: "Not authorized to view these comments" });
  }

  try {
    const result = await commentsModel.getUserComments(user_id);
    res.status(200).json(result.rows);
  } catch (err) {
    res.status(500).json({
      error: "Failed to retrieve user comments",
      details: err.message,
    });
  }
}

/* Admin only */
async function showAllComments(req, res) {
  // Changed from showAllPhotoComments
  try {
    const commentResult = await commentsModel.getAllComments();

    if (commentResult.rows.length === 0) {
      return res.status(200).json([]); // Return empty array instead of 404
    }

    res.status(200).json(commentResult.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Failed to fetch comments", details: err.message }); // Updated error message
  }
}

module.exports = {
  showActivePhotoComments,
  showAllPhotoComments,
  addComment,
  editComment,
  deleteComment,
  showUserComments,
  showAllComments,
};

================
File: controllers/DownloadsController.js
================
const downloadsModel = require("../models/DownloadsModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function checkDownloads(id_user, id_photo) {
  try {
    const result = await downloadsModel.getAllDownloads();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    console.log(err);
    throw err;
  }
}

async function addDownload(req, res) {
  let id_photo = req.params.id_photo;
  const id_user = req.user.id;
  id_photo = sanitizeHtml(id_photo);
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkDownloads(id_user, id_photo);
      if (check === true) {
        res
          .status(200)
          .json({ warning: "You have already downloaded this photo!" });
      } else {
        await downloadsModel.addDownload(id, id_user, id_photo);
        res
          .status(201)
          .json({ message: "Download added to library successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUserDownloads(req, res) {
  let u_id = req.params.u_id;
  u_id = sanitizeHtml(u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these downloads" });
    }
    try {
      const result = await downloadsModel.getUserDownloads(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

module.exports = {
  showUserDownloads,
  addDownload,
};

================
File: controllers/LikesController.js
================
const likesModel = require("../models/LikesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.countPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function getUserLikes(req, res) {
  let u_id = sanitizeHtml(req.params.u_id);
  if (validator.isUUID(u_id)) {
    if (u_id !== req.user.id) {
      return res
        .status(403)
        .json({ error: "Not authorized to view these likes" });
    }
    try {
      const result = await likesModel.getUserLikes(u_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid user id!" });
  }
}

async function getPhotoLikes(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  if (validator.isUUID(p_id)) {
    try {
      const result = await likesModel.getPhotoLikes(p_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid photo id!" });
  }
}

async function checkLikes(id_user, id_photo) {
  try {
    const result = await likesModel.getAllLikes();
    return result.rows.some(
      (item) => item.id_photo === id_photo && item.id_user === id_user
    );
  } catch (err) {
    throw err;
  }
}

async function addLike(req, res) {
  const id_photo = sanitizeHtml(req.params.id_photo);
  const id_user = req.user.id;
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(id_user) &&
    validator.isUUID(id_photo)
  ) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        res.status(200).json({ warning: "You have already liked this photo!" });
      } else {
        await likesModel.likePhoto(id, id_user, id_photo);
        res.status(201).json({ message: "Like added successfully!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deleteLike(req, res) {
  let { id_photo } = req.params;
  const id_user = req.user.id; // Get user id from the authenticated token
  id_photo = sanitizeHtml(id_photo);
  if (validator.isUUID(id_user) && validator.isUUID(id_photo)) {
    try {
      const check = await checkLikes(id_user, id_photo);
      if (check === true) {
        await likesModel.unlikePhoto(id_user, id_photo);
        res.status(200).json({ message: "Photo unliked!" });
      } else {
        res.status(200).json({ warning: "You have not liked this photo!" });
      }
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

/* Check if user has liked specific photo */
async function checkIfUserLiked(req, res) {
  if (!req.user) {
    return res.status(401).json({ error: "Authentication required" });
  }
  let { id_photo } = req.params;
  id_photo = sanitizeHtml(id_photo);
  const id_user = req.user.id; // From the JWT token

  if (!validator.isUUID(id_photo) || !validator.isUUID(id_user)) {
    return res.status(400).json({
      error: `Invalid photo or user ID: photo: ${id_photo} user: ${id_user}`,
    });
  }

  try {
    const result = await likesModel.checkUserLike(id_user, id_photo);
    res.status(200).json({ hasLiked: result.rows[0].exists });
  } catch (err) {
    res.status(500).json({
      error: "Internal server error",
      details: err.message,
    });
  }
}

module.exports = {
  showLikes,
  getUserLikes,
  getPhotoLikes,
  addLike,
  deleteLike,
  checkIfUserLiked,
};

================
File: controllers/PhotoController.js
================
const photoModel = require("../models/PhotoModel");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

async function showActivePhotos(req, res) {
  try {
    const result = await photoModel.getActivePhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhotos(req, res) {
  try {
    const result = await photoModel.getPhotos();
    res.status(200).json(result.rows);
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

async function showPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getPhoto(id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotos(req, res) {
  let id = sanitizeHtml(req.params.id);

  if (validator.isUUID(id)) {
    try {
      const result = await photoModel.getUserPhotos(id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function showUserPhotoById(req, res) {
  let p_id = sanitizeHtml(req.params.p_id);
  let u_id = sanitizeHtml(req.params.u_id);

  if (validator.isUUID(p_id) && validator.isUUID(u_id)) {
    try {
      const result = await photoModel.getUserPhotoById(p_id, u_id);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      res.status(200).json(result.rows[0]);
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid id!" });
  }
}

async function newPhoto(req, res) {
  let { name, description, path, status } = req.body;
  let user_id = req.user.id; // Get user id from the authenticated token
  let id = uuidv4();

  if (
    status === undefined ||
    status === "" ||
    status === null ||
    path === undefined ||
    path === null ||
    path === ""
  ) {
    status = false;
  }

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);
  path = sanitizeHtml(path);

  if (
    validator.isUUID(user_id) &&
    validator.isUUID(id) &&
    (validator.isAscii(path) | (path === "") ||
      path === null ||
      path === undefined) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      await photoModel.createPhoto(
        id,
        user_id,
        name,
        description,
        path,
        status
      );
      res.status(201).json({ message: `Photo ${name} created successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function deletePhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  if (validator.isUUID(id)) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to delete this photo" });
      }
      await photoModel.deletePhoto(id);
      res.status(200).json({ message: `Photo deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function editPhoto(req, res) {
  let id = sanitizeHtml(req.params.id);
  let { name, description, status } = req.body;

  name = sanitizeHtml(name);
  description = sanitizeHtml(description);

  if (
    validator.isUUID(id) &&
    (status === true || status === false) &&
    name &&
    name.trim() !== ""
  ) {
    try {
      const photo = await photoModel.getPhoto(id);
      if (photo.rows.length === 0) {
        return res.status(404).json({ error: "Photo not found" });
      }
      if (photo.rows[0].user_id !== req.user.id) {
        return res
          .status(403)
          .json({ error: "Not authorized to edit this photo" });
      }
      await photoModel.editPhoto(name, description, status, id);
      res.status(200).json({ message: `Photo updated successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error!", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

module.exports = {
  showActivePhotos,
  showPhotos,
  showPhoto,
  showUserPhotos,
  showUserPhotoById,
  newPhoto,
  deletePhoto,
  editPhoto,
};

================
File: controllers/Photos_CategoriesController.js
================
const { v4: uuidv4 } = require("uuid");
const photosCategoriesModel = require("../models/Photos_CategoriesModel");
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");

async function addPhotoCategory(req, res) {
  const { photo_id, category_id } = req.body;
  const id = uuidv4();

  if (
    validator.isUUID(id) &&
    validator.isUUID(photo_id) &&
    validator.isUUID(category_id)
  ) {
    try {
      await photosCategoriesModel.addPhotoCategory(id, photo_id, category_id);
      res
        .status(201)
        .json({ message: "Category assigned to photo successfully" });
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to assign category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid input data" });
  }
}

async function getPhotoCategory(req, res) {
  const photo_id = sanitizeHtml(req.params.id);

  if (validator.isUUID(photo_id)) {
    try {
      const result = await photosCategoriesModel.getPhotoCategory(photo_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get category", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid photo ID" });
  }
}

async function getCategoryPhotos(req, res) {
  const category_id = sanitizeHtml(req.params.id);

  if (validator.isUUID(category_id)) {
    try {
      const result = await photosCategoriesModel.getCategoryPhotos(category_id);
      res.status(200).json(result.rows);
    } catch (err) {
      res
        .status(500)
        .json({ message: "Failed to get photos", error: err.message });
    }
  } else {
    res.status(400).json({ message: "Invalid category ID" });
  }
}

module.exports = {
  addPhotoCategory,
  getPhotoCategory,
  getCategoryPhotos,
};

================
File: controllers/UserController.js
================
const userModel = require("../models/UserModel");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
require("dotenv").config();
const secret = process.env.JWT_SECRET;
const sanitizeHtml = require("sanitize-html");
const validator = require("validator");
const { v4: uuidv4 } = require("uuid");

// Token generation
function generateToken(user) {
  return jwt.sign(
    {
      id: user.id,
      username: user.username,
      email: user.email,
      access_level: user.access_level,
    },
    secret,
    { expiresIn: "30d" }
  );
}

async function loginUser(req, res) {
  let { email, password } = req.body;
  email = sanitizeHtml(email);
  password = sanitizeHtml(password);

  if (validator.isEmail(email) && validator.isAlphanumeric(password)) {
    try {
      const user = await userModel.getUserByEmail(email);
      if (user.rows.length === 0) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const isMatch = await bcrypt.compare(password, user.rows[0].password);
      if (!isMatch) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = jwt.sign(
        {
          id: user.rows[0].id,
          username: user.rows[0].username,
          email: user.rows[0].email,
          access_level: user.rows[0].access_level, // Add access_level to token payload
        },
        secret,
        { expiresIn: "30d" }
      );

      // secure: process.env.NODE_ENV === "production"
      res.cookie("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
        sameSite: "lax", // Added security measure
        domain: "localhost",
        path: "/",
      });

      res.status(200).json({
        message: "Login successful",
        token: token,
      });
    } catch (err) {
      res.status(500).json({ error: "Internal server error" });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function showUsers(req, res) {
  try {
    const result = await userModel.getUsers();
    res.send(result.rows);
  } catch (err) {
    res.send(err);
  }
}

async function showUser(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUser(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUsername(req, res) {
  let id = req.params.id;
  id = sanitizeHtml(id);

  if (validator.isUUID(id)) {
    try {
      const result = await userModel.getUsername(id);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  } else {
    res.send("Invalid id!");
  }
}

async function showUserByEmail(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    try {
      const result = await userModel.getUserByEmail(email);
      res.send(result.rows);
    } catch (err) {
      res.send(err);
    }
  }
}

async function registerUser(req, res) {
  let { username, password, email, user_icon } = req.body;
  const id = uuidv4();
  username = sanitizeHtml(username);
  password = sanitizeHtml(password);
  email = sanitizeHtml(email);
  user_icon = sanitizeHtml(user_icon);

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    validator.isEmail(email) &&
    validator.isAlphanumeric(password) &&
    (validator.isAscii(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      const salt = bcrypt.genSaltSync(10);
      const hash = bcrypt.hashSync(password, salt);

      await userModel.newUser(id, username, email, hash, user_icon);

      const user = { id, email, username };
      const token = generateToken(user);

      res.status(201).json({
        message: `User ${email} created successfully!`,
        token,
        user,
      });
    } catch (err) {
      if (err.code === "23505") {
        res.status(400).json({ message: `Email or username already exists!` });
      } else if (err.code === "22P02") {
        res.status(400).json({ message: `Invalid data!` });
      } else {
        console.error(err);
        res
          .status(500)
          .json({ error: "Internal server error", details: err.message });
      }
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function delUser(req, res) {
  let email = req.params.email;
  email = sanitizeHtml(email);

  if (validator.isEmail(email)) {
    // Allow admins to delete any user
    if (!req.user.access_level && email !== req.user.email) {
      return res
        .status(403)
        .json({ error: "Not authorized to delete this user" });
    }
    try {
      await userModel.deleteUser(email);
      // Only clear cookie if user is deleting their own account
      if (email === req.user.email) {
        res.clearCookie("token");
      }
      res.status(200).json({ message: `User ${email} deleted successfully!` });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid email format" });
  }
}

// need to validate using jwt and compare hashed password / id / email / username
async function changePass(req, res) {
  let { email, currentPassword, newPassword } = req.body;

  email = sanitizeHtml(email);
  currentPassword = sanitizeHtml(currentPassword);
  newPassword = sanitizeHtml(newPassword);

  if (email !== req.user.email) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's password" });
  }

  if (
    !validator.isEmail(email) ||
    !validator.isAlphanumeric(currentPassword) ||
    !validator.isAlphanumeric(newPassword)
  ) {
    return res.status(400).json({ error: "Invalid data!" });
  }

  try {
    const user = await userModel.getUserByEmail(email);
    if (user.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const isMatch = await bcrypt.compare(
      currentPassword,
      user.rows[0].password
    );
    if (!isMatch) {
      return res.status(401).json({ error: "Current password is incorrect" });
    }

    const salt = bcrypt.genSaltSync(10);
    const hash = bcrypt.hashSync(newPassword, salt);

    await userModel.editPassword(hash, email);
    res.status(200).json({ message: "Password updated successfully!" });
  } catch (err) {
    console.error("Error in changePass:", err);
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

// validation needed here also
async function changeUser(req, res) {
  let { username, user_icon } = req.body;
  let id = req.params.id;

  username = sanitizeHtml(username);
  user_icon = sanitizeHtml(user_icon);

  if (id !== req.user.id) {
    return res
      .status(403)
      .json({ error: "Not authorized to change this user's information" });
  }

  if (
    validator.isUUID(id) &&
    validator.isAlphanumeric(username) &&
    (validator.isAscii(user_icon) ||
      user_icon === "" ||
      user_icon === null ||
      user_icon === undefined)
  ) {
    try {
      await userModel.editUser(username, user_icon, id);
      res.status(200).json({ message: "User updated successfully!" });
    } catch (err) {
      res
        .status(500)
        .json({ error: "Internal server error", details: err.message });
    }
  } else {
    res.status(400).json({ error: "Invalid data!" });
  }
}

async function logoutUser(req, res) {
  try {
    // Clear the JWT cookie
    res.clearCookie("token");
    res.status(200).json({ message: "Logged out successfully" });
  } catch (err) {
    res
      .status(500)
      .json({ error: "Internal server error", details: err.message });
  }
}

module.exports = {
  showUsers,
  showUser,
  showUsername,
  registerUser,
  showUserByEmail,
  delUser,
  changePass,
  changeUser,
  loginUser,
  logoutUser,
};

================
File: docker-compose.yml
================
services:
  postgres:
    image: postgres:16
    container_name: photostockage-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 12345
      POSTGRES_DB: photostockage
    ports:
      - "5433:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: .
    container_name: photostockage-backend
    depends_on:
      - postgres
    ports:
      - "3000:3000"
    env_file:
      - .env.docker

  frontend:
    build:
      context: ../photostockage
    container_name: photostockage-frontend
    ports:
      - "3001:3001"
    depends_on:
      - backend

volumes:
  postgres_data:
    driver: local

================
File: dockerfile
================
FROM node:18-alpine

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]

================
File: documentation.md
================
# PhotoStockage Backend Documentation

## Table of Contents

1. [Project Overview](#project-overview)
2. [System Architecture](#system-architecture)
3. [Getting Started](#getting-started)
4. [API Reference](#api-reference)
5. [Database Schema](#database-schema)
6. [Authentication & Authorization](#authentication--authorization)
7. [Security Features](#security-features)
8. [Testing](#testing)
9. [Error Handling](#error-handling)

## Project Overview

PhotoStockage is a secure backend service for managing photo storage and sharing. It provides a RESTful API that handles user management, photo uploads, social interactions (likes, comments), and content categorization.

### Key Features

- User authentication and authorization
- Photo management (upload, edit, delete)
- Social features (likes, comments)
- Download tracking
- Category management
- Admin functionality

### Tech Stack

- Node.js
- Express.js
- PostgreSQL
- JWT for authentication
- Jest for testing

## System Architecture

### Core Components

1. **Server Configuration (index.js)**

   - Express application setup
   - Middleware configuration
   - Route registration
   - CORS and security settings

2. **Middleware Layer (middleware/)**

   - Authentication validation
   - Admin access control
   - Rate limiting
   - Security headers (Helmet)

3. **Controllers Layer (controllers/)**

   - Business logic implementation
   - Request handling
   - Response formatting
   - Error management

4. **Models Layer (models/)**

   - Database interactions
   - Data validation
   - Query execution

5. **Routes Layer (routes/)**
   - API endpoint definitions
   - Route protection
   - Request routing

### Directory Structure

```
├── controllers/
│   ├── CategoriesController.js
│   ├── CommentsController.js
│   ├── DownloadsController.js
│   ├── LikesController.js
│   ├── PhotoController.js
│   └── UserController.js
├── middleware/
│   └── authMiddleware.js
├── models/
│   ├── CategoriesModel.js
│   ├── CommentsModel.js
│   ├── DownloadsModel.js
│   ├── LikesModel.js
│   ├── PhotoModel.js
│   └── UserModel.js
├── routes/
│   ├── categoriesRoute.js
│   ├── commentsRoute.js
│   ├── downloadsRoute.js
│   ├── likesRoute.js
│   ├── photoRoute.js
│   └── userRoute.js
├── utils/
│   └── db.js
└── index.js
```

## Getting Started

### Prerequisites

- Node.js v12 or higher
- PostgreSQL 12 or higher
- npm or yarn

### Installation

1. Clone the repository
2. Install dependencies:

```bash
npm install
```

3. Set up environment variables:

```env
DATABASE_URL=postgresql://username:password@localhost:5432/database
JWT_SECRET=your_jwt_secret
NODE_ENV=development
```

4. Start the server:

```bash
npm start
```

## API Reference

### User Management

#### Register User

```http
POST /user/register
Content-Type: application/json

{
  "username": "string",
  "email": "string",
  "password": "string",
  "user_icon": "string" (optional)
}
```

#### Login

```http
POST /user/login
Content-Type: application/json

{
  "email": "string",
  "password": "string"
}
```

### Photo Management

#### Upload Photo

```http
POST /photos/add_photo
Authorization: Bearer token
Content-Type: application/json

{
  "name": "string",
  "description": "string",
  "path": "string",
  "status": boolean
}
```

#### Get Photos

```http
GET /photos/photos
```

### Categories

#### Create Category (Admin only)

```http
POST /categories
Authorization: Bearer token
Content-Type: application/json

{
  "name": "string",
  "description": "string"
}
```

## Database Schema

### Users Table

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY,
  username VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255) NOT NULL,
  user_icon VARCHAR(255),
  access_level BOOLEAN DEFAULT FALSE
);
```

### Photos Table

```sql
CREATE TABLE photos (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  path VARCHAR(255),
  status BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## Authentication & Authorization

### JWT Implementation

- Tokens generated upon login/registration
- 30-day expiration
- Stored in HTTP-only cookies
- Contains user ID, username, email, and access level

### Middleware Protection

```javascript
const authMiddleware = (req, res, next) => {
  const token = req.cookies.token;
  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }
  // Token verification and user attachment to request
};
```

## Security Features

1. **Input Sanitization**

   - HTML sanitization using `sanitize-html`
   - Data validation with `validator`

2. **Rate Limiting**

   - 100 requests per 15 minutes per IP

3. **Security Headers**

   - Helmet middleware implementation
   - XSS protection
   - Content Security Policy
   - Frame protection

4. **Password Security**
   - Bcrypt hashing
   - Salt rounds: 10

## Testing

### Test Structure

```
__tests__/
├── integration/
│   ├── user.test.js
│   ├── comments.test.js
│   ├── likes.test.js
│   ├── photos.test.js
│   └── downloads.test.js
└── setup/
    └── testDb.js
```

### Running Tests

```bash
npm test
```

### Coverage Areas

- User authentication
- CRUD operations
- Permission validation
- Error handling
- Input validation

## Error Handling

### Standard Error Response Format

```javascript
{
  error: string,
  details?: string,
  message?: string
}
```

### HTTP Status Codes

- 200: Success
- 201: Created
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden
- 404: Not Found
- 500: Internal Server Error

================
File: index.js
================
const express = require("express");
const app = express();
const cors = require("cors");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const cookieParser = require("cookie-parser"); // Add this line
const userRoute = require("./routes/userRoute");
const photoRoute = require("./routes/photoRoute");
const categoriesRoute = require("./routes/categoriesRoute");
const likesRoute = require("./routes/likesRoute");
const downloadsRoute = require("./routes/downloadsRoute");
const commentsRoute = require("./routes/commentsRoute");
const photosCategoriesRouter = require("./routes/photos_categoriesRoute");

app.use(express.json());
app.use(helmet());
app.use(
  cors({
    origin: [
      "http://localhost:3001",
      "http://192.168.1.190:3001",
      /^http:\/\/192\.168\.1\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]+)?$/,
    ],
    credentials: true, // Allows cookies with CORS
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "UPDATE"],
    allowedHeaders: ["Content-Type", "Authorization", "Accept"],
  })
);
app.use(cookieParser()); // Uses the cookie parser

const limiter = rateLimit({
  windowsMs: 15 * 60 * 1000, // 15 minutes
  max: 10000, // Limit each IP to x requests per `window` (here, per 15 minutes)
});

app.use(limiter);

app.use("/user", userRoute);
app.use("/photos", photoRoute);
app.use("/categories", categoriesRoute);
app.use("/likes", likesRoute);
app.use("/downloads", downloadsRoute);
app.use("/comments", commentsRoute);
app.use("/photos_categories", photosCategoriesRouter);

// app.listen(3000, () => {
//   console.log("Server is running on port 3000");
// });

if (process.env.NODE_ENV !== "test") {
  app.listen(3000, () => {
    console.log("Server is running on port 3000");
  });
}

module.exports = app;

================
File: middleware/authMiddleware.js
================
const jwt = require("jsonwebtoken");
require("dotenv").config();

const authMiddleware = (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return res.status(401).json({ error: "Token expired" });
    }
    return res.status(401).json({ error: "Invalid token" });
  }
};

const isAdmin = (req, res, next) => {
  if (!req.user || !req.user.access_level) {
    return res.status(403).json({ error: "Admin access required" });
  }
  next();
};

module.exports = { authMiddleware, isAdmin };

================
File: models/CategoriesModel.js
================
const { pool } = require("../utils/db");

function getCategories() {
  return pool.query(`SELECT * FROM categories`);
}

/* Untested functionality */
function getCategoryById(id) {
  return pool.query(`SELECT * FROM categories WHERE id = $1`, [id]);
}

/* Untested functionality */
function getCategoryByName(name) {
  return pool.query(`SELECT * FROM categories WHERE name = $1`, [name]);
}

/* Untested functionality */
function createCategory(id, name, description) {
  return pool.query(
    `INSERT INTO categories (id, name, description) VALUES ($1, $2, $3) RETURNING (id, name)`,
    [id, name, description]
  );
}

/* Edit category, admin only */
function editCategory(id, name, description) {
  return pool.query(
    `UPDATE categories SET name = $2, description = $3 WHERE id = $1 RETURNING (id, name)`,
    [id, name, description]
  );
}

/* Delete category, admin only */
function deleteCategory(id) {
  return pool.query("DELETE FROM categories WHERE id = $1 RETURNING id", [id]);
}

module.exports = {
  getCategories,
  createCategory,
  getCategoryById,
  getCategoryByName,
  editCategory,
  deleteCategory,
};

================
File: models/CommentsModel.js
================
const { pool } = require("../utils/db");

function getPhotoComments(p_id) {
  return pool.query(
    `SELECT * FROM comments WHERE id_photo = $1 AND status = true`,
    [p_id]
  );
}

function getAllPhotoComments(p_id) {
  return pool.query(`SELECT * FROM comments WHERE id_photo = $1`, [p_id]);
}

function addComment(id, user_id, photo_id, content) {
  return pool.query(
    `INSERT INTO comments (id, id_user, id_photo, content, status) VALUES ($1, $2, $3, $4, true) RETURNING (id, id_photo)`,
    [id, user_id, photo_id, content]
  );
}

function deleteComment(comment_id, user_id) {
  return pool.query(
    `DELETE FROM comments WHERE id = $1 AND id_user = $2 RETURNING (id)`,
    [comment_id, user_id]
  );
}

function edtiComment(comment_id, user_id, content) {
  return pool.query(
    `UPDATE comments SET content = $1 WHERE id = $2 AND id_user = $3 RETURNING (id)`,
    [content, comment_id, user_id]
  );
}

// Helper function to check if the photo is active or not
function getPhotoStatus(photo_id) {
  return pool.query(`SELECT status FROM photos WHERE id = $1`, [photo_id]);
}

// Helper function to get details of comments
function getCommentDetails(comment_id) {
  return pool.query(`SELECT * FROM comments WHERE id = $1`, [comment_id]);
}

// Get user's comments
function getUserComments(user_id) {
  return pool.query(
    `SELECT 
      c.id as comment_id,
      c.content,
      c.status as comment_status,
      p.id as photo_id,
      p.name as photo_name,
      p.status as photo_status
    FROM comments c
    JOIN photos p ON c.id_photo = p.id
    WHERE c.id_user = $1`,
    [user_id]
  );
}

function getAllComments() {
  return pool.query(`SELECT * FROM comments ORDER BY id DESC`); // Added ordering
}

module.exports = {
  getPhotoComments,
  getAllPhotoComments,
  addComment,
  deleteComment,
  edtiComment,
  getPhotoStatus,
  getCommentDetails,
  getUserComments,
  getAllComments,
};

================
File: models/DownloadsModel.js
================
const { pool } = require("../utils/db");

function getUserDownloads(u_id) {
  return pool.query(
    `
        SELECT * FROM downloads
        JOIN photos ON downloads.id_photo = photos.id
        WHERE id_user = $1`,
    [u_id]
  );
}

function addDownload(id, u_id, p_id) {
  return pool.query(
    `INSERT INTO downloads (id, id_user, id_photo) VALUES ($1, $2, $3) RETURNING (id_photo)`,
    [id, u_id, p_id]
  );
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllDownloads() {
  return pool.query(`SELECT id_user, id_photo FROM downloads`);
}

module.exports = {
  getUserDownloads,
  addDownload,
  getAllDownloads,
};

================
File: models/LikesModel.js
================
const { pool } = require("../utils/db");

/* Returns all the photos the user has liked */
/* Change star to specific fields due to memory leaks! */
function getUserLikes(u_id) {
  return pool.query(
    `
        SELECT * FROM likes l
        JOIN photos p ON l.id_photo = p.id
        WHERE l.id_user = $1`,
    [u_id]
  );
}

/* Should return the username of people that liked the photo */
/* Change star to specific fields due to memory leaks! */
function getPhotoLikes(p_id) {
  return pool.query(
    `
        SELECT u.id, u.username, u.user_icon, l.id, l.id_photo FROM likes l
        JOIN users u ON l.id_user = u.id
        WHERE l.id_photo = $1`,
    [p_id]
  );
}

/* Returns the number of likes on a specific photo */
function countPhotoLikes(p_id) {
  return pool.query(
    `SELECT COUNT(*) FROM likes l
    JOIN photos p ON l.id_photo = p.id
    WHERE l.id_photo = $1`,
    [p_id]
  );
}

/* Unlike photo */
function unlikePhoto(u_id, p_id) {
  return pool.query(
    `DELETE FROM likes WHERE id_user = $1 AND id_photo = $2 RETURNING (id_photo)`,
    [u_id, p_id]
  );
}

/* Like photo */
function likePhoto(id, u_id, p_id) {
  return pool.query(
    `INSERT INTO likes (id, id_user, id_photo) VALUES ($1, $2, $3) RETURNING (id_photo)`,
    [id, u_id, p_id]
  );
}

/* Function to check if the user has liked a specific photo */
function checkUserLike(user_id, photo_id) {
  return pool.query(
    "SELECT EXISTS(SELECT 1 FROM likes WHERE id_user = $1 AND id_photo = $2)",
    [user_id, photo_id]
  );
}

/* Helper function that returns all likes */
/* Pass the ids here to avoid fetching ALL of the data dummass */
function getAllLikes() {
  return pool.query(`SELECT id_user, id_photo FROM likes`);
}

module.exports = {
  getUserLikes,
  getPhotoLikes,
  countPhotoLikes,
  likePhoto,
  getAllLikes,
  unlikePhoto,
  checkUserLike,
};

================
File: models/PhotoModel.js
================
const { pool } = require("../utils/db");

function getActivePhotos() {
  return pool.query("SELECT * FROM photos WHERE status = true");
}

function getPhotos() {
  return pool.query("SELECT * FROM photos");
}

function getPhoto(id) {
  const req = `SELECT * FROM photos WHERE id = $1`;
  return pool.query(req, [id]);
}

function getUserPhotos(id) {
  const req = `SELECT * FROM photos WHERE user_id = $1`;
  return pool.query(req, [id]);
}

function getUserPhotoById(p_id, u_id) {
  const req = `SELECT * FROM photos WHERE id = $1 AND user_id = $2`;
  return pool.query(req, [p_id, u_id]);
}

function createPhoto(id, user_id, name, description, path, status) {
  const req = `INSERT INTO photos (id, user_id, name, description, path, status) VALUES ($1, $2, $3, $4, $5, $6) RETURNING (id, name)`;
  return pool.query(req, [id, user_id, name, description, path, status]);
}

function deletePhoto(id) {
  const req = `DELETE FROM photos WHERE id = $1 RETURNING id`;
  return pool.query(req, [id]);
}

function editPhoto(name, description, status, id) {
  const req = `UPDATE photos SET name = $1, description = $2, status = $3 WHERE id = $4 RETURNING (id, name)`;
  return pool.query(req, [name, description, status, id]);
}

module.exports = {
  getActivePhotos,
  getPhotos,
  getPhoto,
  getUserPhotos,
  getUserPhotoById,
  createPhoto,
  deletePhoto,
  editPhoto,
};

================
File: models/Photos_CategoriesModel.js
================
const { pool } = require("../utils/db");

function addPhotoCategory(id, photo_id, category_id) {
  return pool.query(
    `INSERT INTO photos_categories (id, id_photo, id_category) 
     VALUES ($1, $2, $3)`,
    [id, photo_id, category_id]
  );
}

function getPhotoCategory(photo_id) {
  return pool.query(
    `SELECT c.* FROM categories c 
     JOIN photos_categories pc ON c.id = pc.id_category 
     WHERE pc.id_photo = $1`,
    [photo_id]
  );
}

function getCategoryPhotos(category_id) {
  return pool.query(
    `SELECT p.* FROM photos p 
     JOIN photos_categories pc ON p.id = pc.id_photo 
     WHERE pc.id_category = $1 AND p.status = true`,
    [category_id]
  );
}

module.exports = {
  addPhotoCategory,
  getPhotoCategory,
  getCategoryPhotos,
};

================
File: models/UserModel.js
================
const { pool } = require("../utils/db");

function getUsers() {
  return pool.query(`SELECT id, username, email, user_icon FROM users`);
}

function getUser(id) {
  const req = `SELECT id, username, email, user_icon FROM users WHERE id = $1`;
  return pool.query(req, [id]);
}

function getUserByEmail(email) {
  const req = `SELECT * FROM users WHERE email = $1`;
  return pool.query(req, [email]);
}

function getUsername(id) {
  const req = `SELECT username FROM users WHERE id = $1`;
  return pool.query(req, [id]);
}

function newUser(id, username, email, password, user_icon) {
  const req = `INSERT INTO users (id, username, email, password, user_icon) VALUES ($1, $2, $3, $4, $5) RETURNING (username)`;
  return pool.query(req, [id, username, email, password, user_icon]);
}

function deleteUser(email) {
  const req = `DELETE FROM users WHERE email = $1 RETURNING (username)`;
  return pool.query(req, [email]);
}

function editUser(username, user_icon, id) {
  const req = `UPDATE users SET username = $1, user_icon = $2 WHERE id = $3 RETURNING (username)`;
  return pool.query(req, [username, user_icon, id]);
}

async function editPassword(password, email) {
  const req = `UPDATE users SET password = $1 WHERE email = $2 RETURNING (username)`;
  return pool.query(req, [password, email]);
}

module.exports = {
  getUsers,
  getUser,
  getUsername,
  newUser,
  getUserByEmail,
  deleteUser,
  editUser,
  editPassword,
};

================
File: package.json
================
{
  "name": "photostockage-backend",
  "version": "0.0.1",
  "description": "Backend for a project for my training at m2i",
  "main": "index.js",
  "scripts": {
    "test": "set NODE_ENV=test&& jest --runInBand --detectOpenHandles --forceExit",
    "start": "npx nodemon index.js"
  },
  "keywords": [
    "backend",
    "node",
    "nodejs"
  ],
  "author": "Sigmund Frost",
  "license": "MIT",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "sanitize-html": "^2.13.0",
    "sequelize": "^6.37.3",
    "uuidv4": "^6.2.13",
    "validator": "^13.12.0"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "supertest": "^7.0.0"
  }
}

================
File: routes/categoriesRoute.js
================
const express = require("express");
const categoriesRouter = express.Router();
const categoriesController = require("../controllers/CategoriesController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* Public routes */
categoriesRouter.get("/", categoriesController.showCategories);
categoriesRouter.get("/:id", categoriesController.showCategoryById);
categoriesRouter.get("/name/:name", categoriesController.showCategoryByName);

/* Admin only routes */
categoriesRouter.post(
  "/",
  authMiddleware,
  isAdmin,
  categoriesController.createCategory
);
categoriesRouter.put(
  "/edit/:id",
  authMiddleware,
  isAdmin,
  categoriesController.editCategory
);
categoriesRouter.delete(
  "/delete/:id",
  authMiddleware,
  isAdmin,
  categoriesController.deleteCategory
);

module.exports = categoriesRouter;

================
File: routes/commentsRoute.js
================
const express = require("express");
const commentsRouter = express.Router();
const commentsController = require("../controllers/CommentsController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* Public routes */
commentsRouter.get("/photo/:p_id", commentsController.showActivePhotoComments);
commentsRouter.get("/c_photo/:p_id", commentsController.showAllPhotoComments);
commentsRouter.get(
  "/user/:user_id",
  authMiddleware,
  commentsController.showUserComments
);
commentsRouter.get(
  "/",
  authMiddleware,
  isAdmin,
  commentsController.showAllComments
);

/* Protected routes - require authentication */
// Add new comment
commentsRouter.post(
  "/add/:photo_id",
  authMiddleware,
  commentsController.addComment
);

// Edit comment
commentsRouter.put(
  "/edit/:comment_id",
  authMiddleware,
  commentsController.editComment
);

// Delete comment (accessible by comment owner or admin)
commentsRouter.delete(
  "/delete/:id",
  authMiddleware,
  commentsController.deleteComment
);

module.exports = commentsRouter;

================
File: routes/downloadsRoute.js
================
const express = require("express");
const downloadsRouter = express.Router();
const downloadsController = require("../controllers/DownloadsController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
downloadsRouter.get(
  "/user/:u_id",
  authMiddleware,
  downloadsController.showUserDownloads
);

/* method: POST */
downloadsRouter.post(
  "/download/:id_photo",
  authMiddleware,
  downloadsController.addDownload
);

module.exports = downloadsRouter;

================
File: routes/likesRoute.js
================
const express = require("express");
const likesRouter = express.Router();
const likesController = require("../controllers/LikesController");
const { authMiddleware } = require("../middleware/authMiddleware");

/* method: GET */
likesRouter.get("/likes/:p_id", likesController.showLikes);
likesRouter.get("/user/:u_id", authMiddleware, likesController.getUserLikes);
likesRouter.get("/photo/:p_id", likesController.getPhotoLikes);
likesRouter.get(
  "/check/:id_photo",
  authMiddleware,
  likesController.checkIfUserLiked
);

/* method: POST */
likesRouter.post("/like/:id_photo", authMiddleware, likesController.addLike);

/* method: DELETE */
likesRouter.delete(
  "/like/:id_photo",
  authMiddleware,
  likesController.deleteLike
);

module.exports = likesRouter;

================
File: routes/photoRoute.js
================
const express = require("express");
const photoRouter = express.Router();
const photoController = require("../controllers/PhotoController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* method: GET */
photoRouter.get("/admin", authMiddleware, isAdmin, photoController.showPhotos);
photoRouter.get("/photos", photoController.showActivePhotos);
photoRouter.get("/photo/:id", photoController.showPhoto);
photoRouter.get("/photos/user/:id", photoController.showUserPhotos);
photoRouter.get("/photo/user/:p_id/:u_id", photoController.showUserPhotoById);

/* method: POST */
photoRouter.post("/add_photo", authMiddleware, photoController.newPhoto);

/* method: DELETE */
photoRouter.delete("/delete/:id", authMiddleware, photoController.deletePhoto);

/* method: PUT */
photoRouter.put("/edit/:id", authMiddleware, photoController.editPhoto);

module.exports = photoRouter;

================
File: routes/photos_categoriesRoute.js
================
const express = require("express");
const photosCategoriesRouter = express.Router();
const photosCategoriesController = require("../controllers/Photos_CategoriesController");
const { authMiddleware } = require("../middleware/authMiddleware");

photosCategoriesRouter.post(
  "/add",
  authMiddleware,
  photosCategoriesController.addPhotoCategory
);
photosCategoriesRouter.get(
  "/photo/:id",
  photosCategoriesController.getPhotoCategory
);
photosCategoriesRouter.get(
  "/category/:id",
  photosCategoriesController.getCategoryPhotos
);

module.exports = photosCategoriesRouter;

================
File: routes/userRoute.js
================
const express = require("express");
const userRouter = express.Router();
const userController = require("../controllers/UserController");
const { authMiddleware, isAdmin } = require("../middleware/authMiddleware");

/* method: GET */
userRouter.get("/users", userController.showUsers);
userRouter.get("/user/:id", userController.showUser);
userRouter.get("/username/:id", userController.showUsername);
userRouter.get("/email/:email", userController.showUserByEmail);

/* method: POST */
userRouter.post("/register", userController.registerUser);
userRouter.post("/login", userController.loginUser);
userRouter.post("/logout", authMiddleware, userController.logoutUser);

/* method: DELETE */
userRouter.delete(
  "/delete/:email",
  authMiddleware,
  isAdmin,
  userController.delUser
);

/* method: PUT */
userRouter.put("/changepass", authMiddleware, userController.changePass);
userRouter.put("/changeuser/:id", authMiddleware, userController.changeUser);

module.exports = userRouter;

================
File: Tests.md
================
# Jest Testing Guide for PhotoStockage Backend

## Introduction

This guide explains the test structure and implementation for our Node.js backend application using Jest and Supertest.

## Test Organization

### Directory Structure

```
__tests__/
├── integration/
│   ├── user.test.js
│   ├── comments.test.js
│   ├── likes.test.js
│   ├── photos.test.js
│   └── downloads.test.js
└── setup/
    └── testDb.js
```

### Key Components

- **Jest**: Testing framework
- **Supertest**: HTTP assertions library
- **Pool**: PostgreSQL connection pool
- **JWT**: JSON Web Tokens for authentication

## Test Setup Explained

```javascript
// Basic test file structure
const request = require("supertest");
const app = require("../../index");
const { pool } = require("../../utils/db");
const jwt = require("jsonwebtoken");
const { v4: uuidv4 } = require("uuid");

describe("Feature Group", () => {
  // Setup before tests
  beforeAll(async () => {
    // Database setup code
  });

  // Cleanup after tests
  afterAll(async () => {
    // Database cleanup code
  });

  describe("Specific Feature", () => {
    // Individual test cases
  });
});
```

### Important Concepts

#### 1. Test Lifecycle Hooks

- `beforeAll`: Runs once before all tests
- `afterAll`: Runs once after all tests
- `beforeEach`: Runs before each test
- `afterEach`: Runs after each test

```javascript
beforeAll(async () => {
  // Create test user
  const userId = uuidv4();
  await pool.query(
    "INSERT INTO users (id, username, email) VALUES ($1, $2, $3)",
    [userId, "testuser", "test@test.com"]
  );
});
```

#### 2. Test Structure

```javascript
describe("Feature", () => {
  it("should do something specific", async () => {
    // Arrange (setup)
    const testData = {
      /* ... */
    };

    // Act (perform action)
    const response = await request(app).post("/endpoint").send(testData);

    // Assert (verify results)
    expect(response.status).toBe(200);
  });
});
```

#### 3. Authentication Testing

```javascript
// Generate auth token for testing
const authToken = jwt.sign(
  { id: userId, username: "testuser" },
  process.env.JWT_SECRET
);

// Use token in requests
const response = await request(app)
  .post("/protected-endpoint")
  .set("Cookie", [`token=${authToken}`])
  .send(data);
```

## Common Jest Assertions

```javascript
// Status codes
expect(response.status).toBe(200);

// Response body
expect(response.body).toHaveProperty("token");
expect(Array.isArray(response.body)).toBe(true);
expect(response.body.message).toContain("success");

// Database checks
const dbResult = await pool.query("SELECT * FROM users WHERE id = $1", [
  userId,
]);
expect(dbResult.rows).toHaveLength(1);
```

## Database Testing

### Setup and Cleanup

```javascript
// Clear tables
await pool.query("TRUNCATE users CASCADE");

// Add test data
await pool.query("INSERT INTO users (...) VALUES (...)");

// Cleanup
await pool.end();
```

## Error Testing

```javascript
it("should handle invalid input", async () => {
  const response = await request(app)
    .post("/endpoint")
    .send({ invalid: "data" });

  expect(response.status).toBe(400);
  expect(response.body).toHaveProperty("error");
});
```

## Test Examples

### User Registration Test

```javascript
describe("User Registration", () => {
  it("registers new user successfully", async () => {
    const userData = {
      username: `testuser_${Date.now()}`,
      email: `test_${Date.now()}@test.com`,
      password: "Test123",
    };

    const response = await request(app).post("/user/register").send(userData);

    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty("token");
  });
});
```

### Protected Route Test

```javascript
describe("Protected Routes", () => {
  it("requires authentication", async () => {
    const response = await request(app).get("/protected-route");

    expect(response.status).toBe(401);
  });

  it("allows access with valid token", async () => {
    const response = await request(app)
      .get("/protected-route")
      .set("Cookie", [`token=${validToken}`]);

    expect(response.status).toBe(200);
  });
});
```

## Running Tests

```bash
# Run all tests
npm test

# Run specific test file
npm test -- __tests__/integration/user.test.js

# Run tests in watch mode
npm run test:watch
```

## Best Practices

1. Use unique identifiers (timestamps, UUIDs) for test data
2. Clean up database after tests
3. Test both success and error cases
4. Keep tests independent
5. Use meaningful test descriptions
6. Mock external services when necessary
7. Test API endpoints with different authentication states
8. Verify database state after operations
9. Use appropriate timeout values for async operations
10. Follow the Arrange-Act-Assert pattern

## Common Pitfalls

- Not handling async operations properly
- Database connection leaks
- Dependency on test order
- Missing error cases
- Hardcoded test data
- Not cleaning up test data
- Inadequate authentication testing

================
File: todo.txt
================
i want to add an endpoint that returns all of the user's comments and the related names and ids of the photos that they commented on plus the status of the comment (in addition to the content)

================
File: utils/db.js
================
const { Pool } = require('pg')
require('dotenv').config()

const pool = new Pool({
    connectionString: process.env.DATABASE_URL
})

/* Connection test */

// async function testConnection() {
//     try {
//         // Connect to the database
//         const test = await pool.query('SELECT * FROM users');
//         console.log(test.rows);
//     } catch (err) {
//         console.error('Error connecting to the database:', err.message);
//     }
// }

// testConnection();

module.exports = {
    pool
}
